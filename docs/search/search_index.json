{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"In diesem Projekt werde ich Schritt f\u00fcr Schritt erkl\u00e4ren wie man einen Compiler erstellt und gleichzeitig das Erkl\u00e4rte in Rust implementieren. Auch habe ich die hier benutzten Konzept vorher in meiner eigenen Programmiersprache \"Luna\" ausprobiert und stark erweitert. Das Repository ist auch Teil des Projekts! Inhaltsverzeichnis Was ist ein Compiler? Aufbau eines Compilers Lexer Parser Compiler Interpreter Meine Eigene Sprache: Luna Fazit Generell ist mir die der Compiler gut gelungen, auch wenn er nicht viel kann. Die meisten Konzepte die ich hier benutzt habe sind von einer meiner besten Programmiersprachen Luna , die ich w\u00e4hrend dem Informatik Unterricht meistens programmiert habe.","title":"Home"},{"location":"#inhaltsverzeichnis","text":"Was ist ein Compiler? Aufbau eines Compilers Lexer Parser Compiler Interpreter Meine Eigene Sprache: Luna","title":"Inhaltsverzeichnis"},{"location":"#fazit","text":"Generell ist mir die der Compiler gut gelungen, auch wenn er nicht viel kann. Die meisten Konzepte die ich hier benutzt habe sind von einer meiner besten Programmiersprachen Luna , die ich w\u00e4hrend dem Informatik Unterricht meistens programmiert habe.","title":"Fazit"},{"location":"Aufbau%20eines%20Compilers/","text":"Ein klassischer Compiler kann nicht einfach vom Text zum Byte Code gehen, sondern muss vorher zu verschiedene Strukturen analysiert werden. Die meisten Compiler durchlaufen daf\u00fcr folgenden Schritte, die jeweils auf dem vorherigen Schritt aufbauen: 1. Lexikalische Analyse : Die Atomaren Teile des Textes (sogenannte Tokens) 2. Syntaktische Analyse : Der Syntax Baum, der darstellt wo was ist. 3. Compilierung : Die tats\u00e4chliche Umwandlung in den Byte Code. Weiter zum Lexer","title":"Aufbau eines Compilers"},{"location":"Compiler/","text":"Wie ich schon in dem Abschnitt \" Was ist ein Compiler \" erkl\u00e4rt habe, muss der AST jetzt nur noch in einen Byte Code umgewandelt werden. Closure Ein Closure ist ein eigene Code Instanz die den Byte Code speichert, sowie die Anzahl an ben\u00f6tigten Registern und Konstanten. Die folgende Struktur ist ein Closure in meinem Compiler struct Closure { code: Vec<Located<ByteCode>>, registers: u16, strings: Vec<String>, numbers: Vec<f64>, closures: Vec<Rc<Self>>, } Hier wird ein Array von Byte Codes gespeichert, die Register Anzahl und Konstanten, also Zahlen, Strings, und Referenzen zu anderen Closures die in diesem Teil des Source Codes entstehen k\u00f6nnen. Closures werden vom Interpreter Aufgerufen in einem Call Stack Byte Code Im Interpreter Da Compiler und Interpreter funktional sehr abh\u00e4ngig von einander sind, muss ich vorher ein paar Sachen klar stellen, wie der Interpreter den Byte Code tats\u00e4chlich ausf\u00fchrt. Der Interpreter den ich schreiben werde, hat einen sogenannten Call Stack, der daf\u00fcr zust\u00e4ndig ist sich zu merken, welche Closure gerade ausgef\u00fchrt wird. In dem Call Stack werden Call Frames gespeichert, die wie folgt strukturiert sind: struct CallFrame { closure: Rc<Closure>, ip: Address, stack: Vec<Rc<RefCell<Value>>>, dst: Option<Register>, } Dieser hat eine Referenz zu dem Closure der gerade Ausgef\u00fchrt wird, einen Instruction Pointer der sagt wo im Code der Interpreter sich gerade befindet, einen Stack auf dem Werte gespeichert werden, um mit diesen Operationen auszuf\u00fchren, und einen Wiedergabe Register des Stacks des Call Frames vor diesem Call Frame. Register In meinem Compiler benutze ich so genannte Register um Werte zu speichern und daran Operationen durchzuf\u00fchren sp\u00e4ter beim Interpreter. Um diese Register anzusprechen muss man sie nat\u00fcrlich identifizieren k\u00f6nnen mit Hilfe eines Indexes. Dieser Index kann von 0 bis hoch zu einer beliebigen Gr\u00f6\u00dfe gehen. type Register = u16; Hier definiere ich Typen Aliase, was bedeutet, wenn ich jetzt Register schreibe, ersetzt Rust das mit u16 (16 Bit unsigned integer). Adressen Was auch sp\u00e4ter wichtig f\u00fcr den Interpreter wird ist, wie er zu einer beliebigen Anweisung springen kann. type Address = u32; In meinem Interpreter werden die Positionen der Anweisungen mit einem u32 (32 Bit unsigned integer) angesprochen. Anweisungen Jetzt komme ich zu den tats\u00e4chlichen Byte Code den ich f\u00fcr diese Sprache geschrieben habe: enum ByteCode { #[default] None, Jump { addr: Address, }, JumpIf { not: bool, cond: Register, addr: Address, }, Call { func: Register, offset: Register, args_len: u8, dst: Option<Register>, }, Return { src: Option<Register>, }, Move { dst: Register, src: Register, }, String { dst: Register, addr: Address, }, Number { dst: Register, addr: Address, }, Closure { dst: Register, addr: Address, }, Global { dst: Register, addr: Address, }, SetGlobal { addr: Address, src: Register }, Binary { op: BinaryOperation, dst: Register, left: Register, right: Register, }, Unary { op: UnaryOperation, dst: Register, src: Register, }, } enum BinaryOperation { Add, Sub, Mul, Div, Mod, Pow, EQ, NE, LT, GT, LE, GE, And, Or, } enum UnaryOperation { Neg, Not, } Das sind alle n\u00f6tigen Anweisungen f\u00fcr meine Sprache. Jump Jump { addr: Address, } Sagt dem Interpreter, dass er zu einer bestimmten Adresse springen soll. Jump If JumpIf { not: bool, cond: Register, addr: Address, } Sagt dem Interpreter, dass er zu einer bestimmten Adresse springen soll, falls der Wert in dem Register cond wahr ist. Dieser Boolesche Wert kann mit dem not = true verneint werden. Call Call { func: Register, offset: Register, args_len: u8, dst: Option<Register>, }, Ruft die Funktion in Register func auf (wenn der Wert \u00fcberhaupt eine Funktion ist) und gibt optional den Wiedergabewert der Funktion in ein bestimmtes Register zur\u00fcck. Die Argumente f\u00fcr diesen Call werden mit offset , wo die Argumente im Stack anfangen, und args_len , wie viele Argumente eingenommen werde, angegeben. Return Return { src: Option<Register>, }, Geht aus dem jetzigen Call raus mit einen Optionalen Wiedergabewert. Move Move { dst: Register, src: Register, }, Kopiert den Wert von Register src zu dst . String, Number und Closure String { dst: Register, addr: Address, // address to string pool }, Number { dst: Register, addr: Address, // address to number pool }, Closure { dst: Register, addr: Address, // address to closure reference pool }, Alle drei Anweisungen sagen dem Interpreter er soll eine Konstante aus dem Konstanten Pool in das dst Register kopieren. Diese Konstanten sind jeweils Zahlen ( f64 ), Strings und Closures. Diese Werden jeweils in jedem Closure gespeichert. Global Global { dst: Register, addr: Address, }, Diese Anweisung funktioniert fast wie die f\u00fcr die Konstanten, dennoch wird hier nicht aus dem Konstanten Pool genommen, sondern aus der Globalen Umgebung. Daf\u00fcr wird ein String aus den Strings des Closures kopiert und dann wird dieser String als Identifier in der Globalen Umgebung gesucht. Wenn kein passender Schl\u00fcssel gefunden wird, wird null in das Register stattdessen geladen. Set Global SetGlobal { addr: Address, src: Register }, Setzt den Wert des Schl\u00fcssels (aus dem String Pool) der Globalen Umgebung auf den Wert in dem src Registers. Binary und Unary Binary { op: BinaryOperation, dst: Register, left: Register, right: Register, }, Unary { op: UnaryOperation, dst: Register, src: Register, }, Diese Anweisungen f\u00fchren jeweils ihre Operationen auf den Registern left und right , bzw. f\u00fcr Unary nur right , und setzt den resultierenden Wert in das Register dst . Hier nochmal die Operationen: enum BinaryOperation { Add, // left + right Sub, // left - right Mul, // left * right Div, // left / right Mod, // left % right Pow, // left ^ right EQ, // left == right NE, // left != right LT, // left < right GT, // left > right LE, // left <= right GE, // left >= right And, // left & right Or, // left | right } enum UnaryOperation { Neg, // -right Not, // !right } Compiler Jetzt kommen wir zum tats\u00e4chlichen Compilierungsvorgang. Der Compiler den ich schreibe basiert auf einem Frame und Scope Prinzip. struct Compiler { frames: Vec<Frame>, // frame stack } struct Frame { closure: Closure, // editable closure registers: Register, // currently used registers scopes: Vec<Scope>, // scope stack } struct Scope { locals: HashMap<String, Register>, // table of variable register pairs offset: Register, // register stack offset } Der Compiler hat einen Frame Stack und compiliert immer nur den letzen Frame. Jeder Frame hat einen ver\u00e4nderbaren Closure, die Anzahl an momentan benutzen Registern und ein Scope Stack. Jeder Scope hat eine Tabelle wo Variablen und ihre Register Indexes gespeichert werden, sowie den Register Stack Offset, der angibt an Welchem Register Index der Scope anf\u00e4ngt. Implementierung trait Compilable { type Output; type Error; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error>; } Hier definiere ich einen Trait der den Implementierer zum Compilieren wichtige Informationen sowie Funktionen implementieren l\u00e4sst. Chunk impl Compilable for Located<Chunk> { type Output = Closure; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { compiler.push_frame(); // new frame for stat in self.value.0 { stat.compile(compiler)?; // compile every statement } compiler.frame_mut().closure.write(ByteCode::Return { src: None }, self.pos); // mendatory null return let frame = compiler.pop_frame().unwrap(); // pop frame Ok(frame.closure) } } Das hier ist die Implementierung f\u00fcr den Chunk AST. Dieser gibt ein Closure wieder oder als Error einen Compile Error, der momentan noch leer ist. Der Code in Schritten erkl\u00e4rt: 1. Werfe ein neuen Frame auf den Frame Stack 2. Iteriere \u00fcber jedes Statement und compiliere es 3. Schreibe eine Return Anweisung am Ende in das Closure 4. Nimm den Frame den du beim 1. Schritt erstellt hast vom Stack 5. Gib den Closure des Frames wieder Block F\u00fcr den Block AST ist die Implementierung \u00e4hnlich zu der des Chunk AST, nur dass kein neues Frame auf den Frame Stack geworfen wird sonder ein neuer Scope auf den Scope Stack. Statement impl Compilable for Located<Statement> { type Output = Option<Register>; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { let Located { value: stat, pos } = self; match stat { ... } } } Beim Statement habe ich mehrere Varianten die ich alle verschieden compilieren muss. Der Output ist hier ein Optionales Register, denn das Statement kann ein Return Statement sein welche ein den Wert eines Registers wiedergeben kann. Block Statement::Block(block) => Located::new(block, pos).compile(compiler) Compiliere einfach den Block Let Statement::Let { ident: Located { value: ident, pos: _, }, expr, } => { let reg = compiler.frame_mut().new_local(ident); let src = expr.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); Ok(None) } Erstelle einen neue lokale Variable Compiliere die Expression Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register der Expression aus dem 2. Schritt zum Register der Variable aus dem 1. Schritt Assign Statement::Assign { ident: Located { value: ident, pos: ident_pos, }, expr, } => { let reg = compiler.frame_mut().local(&ident); let src = expr.compile(compiler)?; if let Some(reg) = reg { compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); } else { let addr = compiler.frame_mut().closure.new_string(ident); compiler .frame_mut() .closure .write(ByteCode::SetGlobal { addr, src }, pos); } Ok(None) } Finde das Register der lokalen Variable (falls es diese gibt) Compiliere die Expression Wenn du das Register aus dem 1. Schritt gefunden hast Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register der Expression aus dem 2. Schritt zum Register der Variable aus dem 1. Schritt Falls du das Register aus dem 1. Schritt nicht gefunden hast Lege eine neue String Konstante diese Identifiers an Schreibe in den jetzigen Closure eine Set Global Anweisung mit dem Result Register der Expression aus dem 2. Schritt und der Adresse der String Konstante aus dem 4.1. Schritt Call Statement::Call { ident: Located { value: ident, pos: ident_pos, }, args, } => { let func = if let Some(reg) = compiler.frame_mut().local(&ident) { reg } else { let addr = compiler.frame_mut().closure.new_string(ident); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::Global { dst, addr }, ident_pos); dst }; let args_len = args.len() as u8; let offset = compiler.frame().registers; compiler.frame_mut().registers += args_len as Register; for (reg, arg) in (offset..offset + args_len as Register).zip(args) { let pos = arg.pos.clone(); let src = arg.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); } compiler.frame_mut().closure.write( ByteCode::Call { func, offset, args_len, dst: None, }, pos, ); Ok(None) } Finde das Register der Funktion Merke dir das Offset als die jetzige Register Anzahl Addiere die Anzahl an Argumenten auf die Register Anzahl drauf Iteriere \u00fcber jedes Argument Compiliere das Argument und speicher das Result Register Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register aus dem 4.1 Schritt zu dem entsprechenden Argument Register Schreibe in den jetzigen Closure eine Call Anweisung mit dem Register der Funktion aus dem 1. Schritt, das Offset aus dem 2. Schritt, die Argumenten L\u00e4nge, und mit einem leeren Result Register. Def Statement::Def { ident: Located { value: ident, pos: _, }, params, body, } => { let reg = compiler.frame_mut().new_local(ident); let addr = { compiler.push_frame(); for Located { value: param, pos: _, } in params { compiler.frame_mut().new_local(param); } body.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Return { src: None }, pos.clone()); let frame = compiler.pop_frame().unwrap(); let closure = Rc::new(frame.closure); compiler.frame_mut().closure.new_closure(closure) }; compiler .frame_mut() .closure .write(ByteCode::Closure { dst: reg, addr }, pos); Ok(None) } Erstelle einen neue lokale Variable in den jetzigen Closure Compiliere die die Parameter und den Body in einem neuen Frame F\u00fcge einen neuen Frame auf den Frame Stack hinzu Iteriere \u00fcber die Parameter Erstelle eine neue lokale Variable in den neuen Closure Compiliere den Body Schreibe ein leere Return Anweisung in den neuen Closure Nehme den neuen Frame wieder vom Frame Stack runter und speicher eine Referenz zu dem Closure Lege eine neue Closure Konstante in dem Closure Konstanten Pool an Schreibe in den jetzigen Closure eine Closure Anweisung mit der Adresse aus dem 2. Schritt in das Register der Variable aus dem 1. Schritt If Statement::If { cond, case, else_case, } => { let cond = cond.compile(compiler)?; let check_addr = compiler .frame_mut() .closure .write(ByteCode::default(), pos.clone()); case.compile(compiler)?; let case_exit_addr = compiler.frame_mut().closure.write(ByteCode::default(), pos); let else_addr = compiler.frame_mut().closure.code.len() as Address; if let Some(else_case) = else_case { else_case.compile(compiler)?; } let exit_addr = compiler.frame_mut().closure.code.len() as Address; compiler.frame_mut().closure.overwrite( check_addr, ByteCode::JumpIf { not: true, cond, addr: else_addr, }, ); compiler .frame_mut() .closure .overwrite(case_exit_addr, ByteCode::Jump { addr: exit_addr }); Ok(None) } Compiliere die cond Expression und merke dir das Result Register Schreibe eine leere Anweisung in den jetzigen Closure und merke dir dessen Adresse Compiliere den case Block Schreibe eine leere Anweisung in den jetzigen Closure und merke dir dessen Adresse Merke dir die Adresse der n\u00e4chsten Anweisung Falls es einen else_case gibt Compiliere den else_case Block Merke dir die Adresse der Anweisung nach der Letzten \u00dcberschreibe die Anweisung bei der Adresse aus dem 2. Schritt mit einer Jump If Anweisung wo not wahr ist, das Konditionsregister das Result Register aus dem 1. Schritt ist, und die Jump Adresse die Adresse aus dem 5. Schritt ist \u00dcberschreibe die Anweisung bei der Adresse aus dem 4. Schritt mit einer Jump Anweisung wo die Jump Adresse die Adresse aus dem 7. Schritt ist While Statement::While { cond, body } => { let cond_addr = compiler.frame_mut().closure.code.len() as Address; let cond = cond.compile(compiler)?; let check_addr = compiler .frame_mut() .closure .write(ByteCode::default(), pos.clone()); body.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Jump { addr: cond_addr }, pos); let exit_addr = compiler.frame_mut().closure.code.len() as Address; compiler.frame_mut().closure.overwrite( check_addr, ByteCode::JumpIf { not: true, cond, addr: exit_addr, }, ); Ok(None) } Merke dir die Adresse der n\u00e4chsten Anweisung Compiliere die cond Expression und merke dir das Result Register Schreibe eine leere Anweisung in den jetzigen Closure und merke dir dessen Adresse Compiliere den body Block Schreibe eine Jump Anweisung in den jetzigen Closure mit der Adresse aus dem 1. Schritt Merke dir die Adresse der n\u00e4chsten Anweisung \u00dcberschreibe die Anweisung bei der Adresse aus dem 3. Schritt mit einer Jump If Anweisung wo not wahr ist, das Konditionsregister das Result Register aus dem 2. Schritt ist, und die Jump Adresse die Adresse aus dem 7. Schritt ist Return Statement::Return(expr) => { let src = expr.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Return { src: Some(src) }, pos); Ok(Some(src)) } Compiliere die Expression und merke dir den Result Register Schreibe eine Return Anweisung in den jetzigen Closure mit Result Register aus dem 1. Schritt Gebe das Result Register wieder Expression impl Compilable for Located<Expression> { type Output = Register; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { let Located { value: expr, pos } = self; match expr { ... } } } Bei der Expression muss immer ein Register wiedergegeben werden. Atom Expression::Atom(atom) => Located::new(atom, pos).compile(compiler), Einfache Compilierung von dem innerem Atom Binary Expression::Binary { op, left, right } => { let dst = compiler.frame_mut().new_register(); let left = left.compile(compiler)?; let right = right.compile(compiler)?; let op = op.into(); compiler.frame_mut().closure.write( ByteCode::Binary { op, dst, left, right, }, pos, ); Ok(dst) } Erstelle ein neues Result Register f\u00fcr die Operation Compiliere die linke Seite Compiliere die rechte Seite Wandele den Binary Operator in seine entsprechende Binary Operation um Schreibe die Binary Anweisung in den jetzigen Closure Gebe das Result Register aus dem 1. Schritt wieder Unary let dst = compiler.frame_mut().new_register(); let src = right.compile(compiler)?; let op = op.into(); compiler .frame_mut() .closure .write(ByteCode::Unary { op, dst, src }, pos); Ok(dst) Erstelle ein neues Result Register f\u00fcr die Operation Compiliere die rechte Seite Wandele den Unary Operator in seine entsprechende Unary Operation um Schreibe die Unary Anweisung in den jetzigen Closure Gebe das Result Register aus dem 1. Schritt wieder Call Expression::Call { head, args } => { let dst = compiler.frame_mut().new_register(); let func = head.compile(compiler)?; let args_len = args.len() as u8; let offset = compiler.frame().registers; compiler.frame_mut().registers += args_len as Register; for (reg, arg) in (offset..offset + args_len as Register).zip(args) { let pos = arg.pos.clone(); let src = arg.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); } compiler.frame_mut().closure.write( ByteCode::Call { func, offset, args_len, dst: Some(dst), }, pos, ); Ok(dst) } Compiliere die aufzurufende Funktion und merke dir dessen Result Register Merke dir das Offset als die jetzige Register Anzahl Addiere die Anzahl an Argumenten auf die Register Anzahl drauf Iteriere \u00fcber jedes Argument Compiliere das Argument und speicher das Result Register Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register aus dem 4.1 Schritt zu dem entsprechenden Argument Register Schreibe in den jetzigen Closure eine Call Anweisung mit dem Register der Funktion aus dem 1. Schritt, das Offset aus dem 2. Schritt, die Argumenten L\u00e4nge, und mit einem leeren Result Register. Atom impl Compilable for Located<Atom> { type Output = Register; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { let Located { value: atom, pos } = self; match atom { ... } } } Bei dem Atom muss immer ein Register wiedergegeben werden. Expression Atom::Expression(expr) => expr.compile(compiler), Compiliere einfach die Expression Ident Atom::Ident(ident) => Ok(if let Some(reg) = compiler.frame_mut().local(&ident) { reg } else { let addr = compiler.frame_mut().closure.new_string(ident); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::Global { dst, addr }, pos); dst }), Versuche das Register der Variable zu finden Wenn du es gefunden hast: Gebe das Register einfach wieder Wenn du es nicht gefunden hast Lege eine neue String Konstante diese Identifiers an Erstelle ein neues Register Schreibe die Global Anweisung in den jetzigen Closure mit der String Adresse aus dem 2.1 Schritt und dem Register aus dem 2.2 Schritt Number und String Atom::Number(number) => { let addr = compiler.frame_mut().closure.new_number(number); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::Number { dst, addr }, pos); Ok(dst) } Atom::String(string) => { let addr = compiler.frame_mut().closure.new_string(string); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::String { dst, addr }, pos); Ok(dst) } Lege eine neue Konstante an Erstelle ein neues Register Schreibe eine Number/String Anweisung in den jetzigen Closure mit der Konstanten Adresse aus dem 1. Schritt und dem Register aus dem 2. Schritt In einer Funktion Das ganze packe ich noch in eine generische Funktion. pub fn compile<A: Compilable>(ast: A) -> Result<A::Output, A::Error> { ast.compile(&mut Compiler::default()) } A ist hier alles was Compiliert werden kann. Die Funktion ist eigentlich nur eine \u00dcbersetzung und benutzen tut man sie eigentlich nur mit dem Chunk AST (z.B. compile(chunk) wo chunk von Typ Located<Chunk> ist), aber ist generell eine gute Abstraktion um die Erwartung des Sprach-Level von Betrachtern zu senken. Weiter zum Interpreter","title":"Compiler"},{"location":"Compiler/#closure","text":"Ein Closure ist ein eigene Code Instanz die den Byte Code speichert, sowie die Anzahl an ben\u00f6tigten Registern und Konstanten. Die folgende Struktur ist ein Closure in meinem Compiler struct Closure { code: Vec<Located<ByteCode>>, registers: u16, strings: Vec<String>, numbers: Vec<f64>, closures: Vec<Rc<Self>>, } Hier wird ein Array von Byte Codes gespeichert, die Register Anzahl und Konstanten, also Zahlen, Strings, und Referenzen zu anderen Closures die in diesem Teil des Source Codes entstehen k\u00f6nnen. Closures werden vom Interpreter Aufgerufen in einem Call Stack","title":"Closure"},{"location":"Compiler/#byte-code","text":"","title":"Byte Code"},{"location":"Compiler/#im-interpreter","text":"Da Compiler und Interpreter funktional sehr abh\u00e4ngig von einander sind, muss ich vorher ein paar Sachen klar stellen, wie der Interpreter den Byte Code tats\u00e4chlich ausf\u00fchrt. Der Interpreter den ich schreiben werde, hat einen sogenannten Call Stack, der daf\u00fcr zust\u00e4ndig ist sich zu merken, welche Closure gerade ausgef\u00fchrt wird. In dem Call Stack werden Call Frames gespeichert, die wie folgt strukturiert sind: struct CallFrame { closure: Rc<Closure>, ip: Address, stack: Vec<Rc<RefCell<Value>>>, dst: Option<Register>, } Dieser hat eine Referenz zu dem Closure der gerade Ausgef\u00fchrt wird, einen Instruction Pointer der sagt wo im Code der Interpreter sich gerade befindet, einen Stack auf dem Werte gespeichert werden, um mit diesen Operationen auszuf\u00fchren, und einen Wiedergabe Register des Stacks des Call Frames vor diesem Call Frame.","title":"Im Interpreter"},{"location":"Compiler/#register","text":"In meinem Compiler benutze ich so genannte Register um Werte zu speichern und daran Operationen durchzuf\u00fchren sp\u00e4ter beim Interpreter. Um diese Register anzusprechen muss man sie nat\u00fcrlich identifizieren k\u00f6nnen mit Hilfe eines Indexes. Dieser Index kann von 0 bis hoch zu einer beliebigen Gr\u00f6\u00dfe gehen. type Register = u16; Hier definiere ich Typen Aliase, was bedeutet, wenn ich jetzt Register schreibe, ersetzt Rust das mit u16 (16 Bit unsigned integer).","title":"Register"},{"location":"Compiler/#adressen","text":"Was auch sp\u00e4ter wichtig f\u00fcr den Interpreter wird ist, wie er zu einer beliebigen Anweisung springen kann. type Address = u32; In meinem Interpreter werden die Positionen der Anweisungen mit einem u32 (32 Bit unsigned integer) angesprochen.","title":"Adressen"},{"location":"Compiler/#anweisungen","text":"Jetzt komme ich zu den tats\u00e4chlichen Byte Code den ich f\u00fcr diese Sprache geschrieben habe: enum ByteCode { #[default] None, Jump { addr: Address, }, JumpIf { not: bool, cond: Register, addr: Address, }, Call { func: Register, offset: Register, args_len: u8, dst: Option<Register>, }, Return { src: Option<Register>, }, Move { dst: Register, src: Register, }, String { dst: Register, addr: Address, }, Number { dst: Register, addr: Address, }, Closure { dst: Register, addr: Address, }, Global { dst: Register, addr: Address, }, SetGlobal { addr: Address, src: Register }, Binary { op: BinaryOperation, dst: Register, left: Register, right: Register, }, Unary { op: UnaryOperation, dst: Register, src: Register, }, } enum BinaryOperation { Add, Sub, Mul, Div, Mod, Pow, EQ, NE, LT, GT, LE, GE, And, Or, } enum UnaryOperation { Neg, Not, } Das sind alle n\u00f6tigen Anweisungen f\u00fcr meine Sprache.","title":"Anweisungen"},{"location":"Compiler/#jump","text":"Jump { addr: Address, } Sagt dem Interpreter, dass er zu einer bestimmten Adresse springen soll.","title":"Jump"},{"location":"Compiler/#jump-if","text":"JumpIf { not: bool, cond: Register, addr: Address, } Sagt dem Interpreter, dass er zu einer bestimmten Adresse springen soll, falls der Wert in dem Register cond wahr ist. Dieser Boolesche Wert kann mit dem not = true verneint werden.","title":"Jump If"},{"location":"Compiler/#call","text":"Call { func: Register, offset: Register, args_len: u8, dst: Option<Register>, }, Ruft die Funktion in Register func auf (wenn der Wert \u00fcberhaupt eine Funktion ist) und gibt optional den Wiedergabewert der Funktion in ein bestimmtes Register zur\u00fcck. Die Argumente f\u00fcr diesen Call werden mit offset , wo die Argumente im Stack anfangen, und args_len , wie viele Argumente eingenommen werde, angegeben.","title":"Call"},{"location":"Compiler/#return","text":"Return { src: Option<Register>, }, Geht aus dem jetzigen Call raus mit einen Optionalen Wiedergabewert.","title":"Return"},{"location":"Compiler/#move","text":"Move { dst: Register, src: Register, }, Kopiert den Wert von Register src zu dst .","title":"Move"},{"location":"Compiler/#string-number-und-closure","text":"String { dst: Register, addr: Address, // address to string pool }, Number { dst: Register, addr: Address, // address to number pool }, Closure { dst: Register, addr: Address, // address to closure reference pool }, Alle drei Anweisungen sagen dem Interpreter er soll eine Konstante aus dem Konstanten Pool in das dst Register kopieren. Diese Konstanten sind jeweils Zahlen ( f64 ), Strings und Closures. Diese Werden jeweils in jedem Closure gespeichert.","title":"String, Number und Closure"},{"location":"Compiler/#global","text":"Global { dst: Register, addr: Address, }, Diese Anweisung funktioniert fast wie die f\u00fcr die Konstanten, dennoch wird hier nicht aus dem Konstanten Pool genommen, sondern aus der Globalen Umgebung. Daf\u00fcr wird ein String aus den Strings des Closures kopiert und dann wird dieser String als Identifier in der Globalen Umgebung gesucht. Wenn kein passender Schl\u00fcssel gefunden wird, wird null in das Register stattdessen geladen.","title":"Global"},{"location":"Compiler/#set-global","text":"SetGlobal { addr: Address, src: Register }, Setzt den Wert des Schl\u00fcssels (aus dem String Pool) der Globalen Umgebung auf den Wert in dem src Registers.","title":"Set Global"},{"location":"Compiler/#binary-und-unary","text":"Binary { op: BinaryOperation, dst: Register, left: Register, right: Register, }, Unary { op: UnaryOperation, dst: Register, src: Register, }, Diese Anweisungen f\u00fchren jeweils ihre Operationen auf den Registern left und right , bzw. f\u00fcr Unary nur right , und setzt den resultierenden Wert in das Register dst . Hier nochmal die Operationen: enum BinaryOperation { Add, // left + right Sub, // left - right Mul, // left * right Div, // left / right Mod, // left % right Pow, // left ^ right EQ, // left == right NE, // left != right LT, // left < right GT, // left > right LE, // left <= right GE, // left >= right And, // left & right Or, // left | right } enum UnaryOperation { Neg, // -right Not, // !right }","title":"Binary und Unary"},{"location":"Compiler/#compiler","text":"Jetzt kommen wir zum tats\u00e4chlichen Compilierungsvorgang. Der Compiler den ich schreibe basiert auf einem Frame und Scope Prinzip. struct Compiler { frames: Vec<Frame>, // frame stack } struct Frame { closure: Closure, // editable closure registers: Register, // currently used registers scopes: Vec<Scope>, // scope stack } struct Scope { locals: HashMap<String, Register>, // table of variable register pairs offset: Register, // register stack offset } Der Compiler hat einen Frame Stack und compiliert immer nur den letzen Frame. Jeder Frame hat einen ver\u00e4nderbaren Closure, die Anzahl an momentan benutzen Registern und ein Scope Stack. Jeder Scope hat eine Tabelle wo Variablen und ihre Register Indexes gespeichert werden, sowie den Register Stack Offset, der angibt an Welchem Register Index der Scope anf\u00e4ngt.","title":"Compiler"},{"location":"Compiler/#implementierung","text":"trait Compilable { type Output; type Error; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error>; } Hier definiere ich einen Trait der den Implementierer zum Compilieren wichtige Informationen sowie Funktionen implementieren l\u00e4sst.","title":"Implementierung"},{"location":"Compiler/#chunk","text":"impl Compilable for Located<Chunk> { type Output = Closure; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { compiler.push_frame(); // new frame for stat in self.value.0 { stat.compile(compiler)?; // compile every statement } compiler.frame_mut().closure.write(ByteCode::Return { src: None }, self.pos); // mendatory null return let frame = compiler.pop_frame().unwrap(); // pop frame Ok(frame.closure) } } Das hier ist die Implementierung f\u00fcr den Chunk AST. Dieser gibt ein Closure wieder oder als Error einen Compile Error, der momentan noch leer ist. Der Code in Schritten erkl\u00e4rt: 1. Werfe ein neuen Frame auf den Frame Stack 2. Iteriere \u00fcber jedes Statement und compiliere es 3. Schreibe eine Return Anweisung am Ende in das Closure 4. Nimm den Frame den du beim 1. Schritt erstellt hast vom Stack 5. Gib den Closure des Frames wieder","title":"Chunk"},{"location":"Compiler/#block","text":"F\u00fcr den Block AST ist die Implementierung \u00e4hnlich zu der des Chunk AST, nur dass kein neues Frame auf den Frame Stack geworfen wird sonder ein neuer Scope auf den Scope Stack.","title":"Block"},{"location":"Compiler/#statement","text":"impl Compilable for Located<Statement> { type Output = Option<Register>; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { let Located { value: stat, pos } = self; match stat { ... } } } Beim Statement habe ich mehrere Varianten die ich alle verschieden compilieren muss. Der Output ist hier ein Optionales Register, denn das Statement kann ein Return Statement sein welche ein den Wert eines Registers wiedergeben kann.","title":"Statement"},{"location":"Compiler/#block_1","text":"Statement::Block(block) => Located::new(block, pos).compile(compiler) Compiliere einfach den Block","title":"Block"},{"location":"Compiler/#let","text":"Statement::Let { ident: Located { value: ident, pos: _, }, expr, } => { let reg = compiler.frame_mut().new_local(ident); let src = expr.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); Ok(None) } Erstelle einen neue lokale Variable Compiliere die Expression Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register der Expression aus dem 2. Schritt zum Register der Variable aus dem 1. Schritt","title":"Let"},{"location":"Compiler/#assign","text":"Statement::Assign { ident: Located { value: ident, pos: ident_pos, }, expr, } => { let reg = compiler.frame_mut().local(&ident); let src = expr.compile(compiler)?; if let Some(reg) = reg { compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); } else { let addr = compiler.frame_mut().closure.new_string(ident); compiler .frame_mut() .closure .write(ByteCode::SetGlobal { addr, src }, pos); } Ok(None) } Finde das Register der lokalen Variable (falls es diese gibt) Compiliere die Expression Wenn du das Register aus dem 1. Schritt gefunden hast Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register der Expression aus dem 2. Schritt zum Register der Variable aus dem 1. Schritt Falls du das Register aus dem 1. Schritt nicht gefunden hast Lege eine neue String Konstante diese Identifiers an Schreibe in den jetzigen Closure eine Set Global Anweisung mit dem Result Register der Expression aus dem 2. Schritt und der Adresse der String Konstante aus dem 4.1. Schritt","title":"Assign"},{"location":"Compiler/#call_1","text":"Statement::Call { ident: Located { value: ident, pos: ident_pos, }, args, } => { let func = if let Some(reg) = compiler.frame_mut().local(&ident) { reg } else { let addr = compiler.frame_mut().closure.new_string(ident); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::Global { dst, addr }, ident_pos); dst }; let args_len = args.len() as u8; let offset = compiler.frame().registers; compiler.frame_mut().registers += args_len as Register; for (reg, arg) in (offset..offset + args_len as Register).zip(args) { let pos = arg.pos.clone(); let src = arg.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); } compiler.frame_mut().closure.write( ByteCode::Call { func, offset, args_len, dst: None, }, pos, ); Ok(None) } Finde das Register der Funktion Merke dir das Offset als die jetzige Register Anzahl Addiere die Anzahl an Argumenten auf die Register Anzahl drauf Iteriere \u00fcber jedes Argument Compiliere das Argument und speicher das Result Register Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register aus dem 4.1 Schritt zu dem entsprechenden Argument Register Schreibe in den jetzigen Closure eine Call Anweisung mit dem Register der Funktion aus dem 1. Schritt, das Offset aus dem 2. Schritt, die Argumenten L\u00e4nge, und mit einem leeren Result Register.","title":"Call"},{"location":"Compiler/#def","text":"Statement::Def { ident: Located { value: ident, pos: _, }, params, body, } => { let reg = compiler.frame_mut().new_local(ident); let addr = { compiler.push_frame(); for Located { value: param, pos: _, } in params { compiler.frame_mut().new_local(param); } body.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Return { src: None }, pos.clone()); let frame = compiler.pop_frame().unwrap(); let closure = Rc::new(frame.closure); compiler.frame_mut().closure.new_closure(closure) }; compiler .frame_mut() .closure .write(ByteCode::Closure { dst: reg, addr }, pos); Ok(None) } Erstelle einen neue lokale Variable in den jetzigen Closure Compiliere die die Parameter und den Body in einem neuen Frame F\u00fcge einen neuen Frame auf den Frame Stack hinzu Iteriere \u00fcber die Parameter Erstelle eine neue lokale Variable in den neuen Closure Compiliere den Body Schreibe ein leere Return Anweisung in den neuen Closure Nehme den neuen Frame wieder vom Frame Stack runter und speicher eine Referenz zu dem Closure Lege eine neue Closure Konstante in dem Closure Konstanten Pool an Schreibe in den jetzigen Closure eine Closure Anweisung mit der Adresse aus dem 2. Schritt in das Register der Variable aus dem 1. Schritt","title":"Def"},{"location":"Compiler/#if","text":"Statement::If { cond, case, else_case, } => { let cond = cond.compile(compiler)?; let check_addr = compiler .frame_mut() .closure .write(ByteCode::default(), pos.clone()); case.compile(compiler)?; let case_exit_addr = compiler.frame_mut().closure.write(ByteCode::default(), pos); let else_addr = compiler.frame_mut().closure.code.len() as Address; if let Some(else_case) = else_case { else_case.compile(compiler)?; } let exit_addr = compiler.frame_mut().closure.code.len() as Address; compiler.frame_mut().closure.overwrite( check_addr, ByteCode::JumpIf { not: true, cond, addr: else_addr, }, ); compiler .frame_mut() .closure .overwrite(case_exit_addr, ByteCode::Jump { addr: exit_addr }); Ok(None) } Compiliere die cond Expression und merke dir das Result Register Schreibe eine leere Anweisung in den jetzigen Closure und merke dir dessen Adresse Compiliere den case Block Schreibe eine leere Anweisung in den jetzigen Closure und merke dir dessen Adresse Merke dir die Adresse der n\u00e4chsten Anweisung Falls es einen else_case gibt Compiliere den else_case Block Merke dir die Adresse der Anweisung nach der Letzten \u00dcberschreibe die Anweisung bei der Adresse aus dem 2. Schritt mit einer Jump If Anweisung wo not wahr ist, das Konditionsregister das Result Register aus dem 1. Schritt ist, und die Jump Adresse die Adresse aus dem 5. Schritt ist \u00dcberschreibe die Anweisung bei der Adresse aus dem 4. Schritt mit einer Jump Anweisung wo die Jump Adresse die Adresse aus dem 7. Schritt ist","title":"If"},{"location":"Compiler/#while","text":"Statement::While { cond, body } => { let cond_addr = compiler.frame_mut().closure.code.len() as Address; let cond = cond.compile(compiler)?; let check_addr = compiler .frame_mut() .closure .write(ByteCode::default(), pos.clone()); body.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Jump { addr: cond_addr }, pos); let exit_addr = compiler.frame_mut().closure.code.len() as Address; compiler.frame_mut().closure.overwrite( check_addr, ByteCode::JumpIf { not: true, cond, addr: exit_addr, }, ); Ok(None) } Merke dir die Adresse der n\u00e4chsten Anweisung Compiliere die cond Expression und merke dir das Result Register Schreibe eine leere Anweisung in den jetzigen Closure und merke dir dessen Adresse Compiliere den body Block Schreibe eine Jump Anweisung in den jetzigen Closure mit der Adresse aus dem 1. Schritt Merke dir die Adresse der n\u00e4chsten Anweisung \u00dcberschreibe die Anweisung bei der Adresse aus dem 3. Schritt mit einer Jump If Anweisung wo not wahr ist, das Konditionsregister das Result Register aus dem 2. Schritt ist, und die Jump Adresse die Adresse aus dem 7. Schritt ist","title":"While"},{"location":"Compiler/#return_1","text":"Statement::Return(expr) => { let src = expr.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Return { src: Some(src) }, pos); Ok(Some(src)) } Compiliere die Expression und merke dir den Result Register Schreibe eine Return Anweisung in den jetzigen Closure mit Result Register aus dem 1. Schritt Gebe das Result Register wieder","title":"Return"},{"location":"Compiler/#expression","text":"impl Compilable for Located<Expression> { type Output = Register; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { let Located { value: expr, pos } = self; match expr { ... } } } Bei der Expression muss immer ein Register wiedergegeben werden.","title":"Expression"},{"location":"Compiler/#atom","text":"Expression::Atom(atom) => Located::new(atom, pos).compile(compiler), Einfache Compilierung von dem innerem Atom","title":"Atom"},{"location":"Compiler/#binary","text":"Expression::Binary { op, left, right } => { let dst = compiler.frame_mut().new_register(); let left = left.compile(compiler)?; let right = right.compile(compiler)?; let op = op.into(); compiler.frame_mut().closure.write( ByteCode::Binary { op, dst, left, right, }, pos, ); Ok(dst) } Erstelle ein neues Result Register f\u00fcr die Operation Compiliere die linke Seite Compiliere die rechte Seite Wandele den Binary Operator in seine entsprechende Binary Operation um Schreibe die Binary Anweisung in den jetzigen Closure Gebe das Result Register aus dem 1. Schritt wieder","title":"Binary"},{"location":"Compiler/#unary","text":"let dst = compiler.frame_mut().new_register(); let src = right.compile(compiler)?; let op = op.into(); compiler .frame_mut() .closure .write(ByteCode::Unary { op, dst, src }, pos); Ok(dst) Erstelle ein neues Result Register f\u00fcr die Operation Compiliere die rechte Seite Wandele den Unary Operator in seine entsprechende Unary Operation um Schreibe die Unary Anweisung in den jetzigen Closure Gebe das Result Register aus dem 1. Schritt wieder","title":"Unary"},{"location":"Compiler/#call_2","text":"Expression::Call { head, args } => { let dst = compiler.frame_mut().new_register(); let func = head.compile(compiler)?; let args_len = args.len() as u8; let offset = compiler.frame().registers; compiler.frame_mut().registers += args_len as Register; for (reg, arg) in (offset..offset + args_len as Register).zip(args) { let pos = arg.pos.clone(); let src = arg.compile(compiler)?; compiler .frame_mut() .closure .write(ByteCode::Move { dst: reg, src }, pos); } compiler.frame_mut().closure.write( ByteCode::Call { func, offset, args_len, dst: Some(dst), }, pos, ); Ok(dst) } Compiliere die aufzurufende Funktion und merke dir dessen Result Register Merke dir das Offset als die jetzige Register Anzahl Addiere die Anzahl an Argumenten auf die Register Anzahl drauf Iteriere \u00fcber jedes Argument Compiliere das Argument und speicher das Result Register Schreibe in den jetzigen Closure eine Move Anweisung von dem Result Register aus dem 4.1 Schritt zu dem entsprechenden Argument Register Schreibe in den jetzigen Closure eine Call Anweisung mit dem Register der Funktion aus dem 1. Schritt, das Offset aus dem 2. Schritt, die Argumenten L\u00e4nge, und mit einem leeren Result Register.","title":"Call"},{"location":"Compiler/#atom_1","text":"impl Compilable for Located<Atom> { type Output = Register; type Error = Located<CompileError>; fn compile(self, compiler: &mut Compiler) -> Result<Self::Output, Self::Error> { let Located { value: atom, pos } = self; match atom { ... } } } Bei dem Atom muss immer ein Register wiedergegeben werden.","title":"Atom"},{"location":"Compiler/#expression_1","text":"Atom::Expression(expr) => expr.compile(compiler), Compiliere einfach die Expression","title":"Expression"},{"location":"Compiler/#ident","text":"Atom::Ident(ident) => Ok(if let Some(reg) = compiler.frame_mut().local(&ident) { reg } else { let addr = compiler.frame_mut().closure.new_string(ident); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::Global { dst, addr }, pos); dst }), Versuche das Register der Variable zu finden Wenn du es gefunden hast: Gebe das Register einfach wieder Wenn du es nicht gefunden hast Lege eine neue String Konstante diese Identifiers an Erstelle ein neues Register Schreibe die Global Anweisung in den jetzigen Closure mit der String Adresse aus dem 2.1 Schritt und dem Register aus dem 2.2 Schritt","title":"Ident"},{"location":"Compiler/#number-und-string","text":"Atom::Number(number) => { let addr = compiler.frame_mut().closure.new_number(number); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::Number { dst, addr }, pos); Ok(dst) } Atom::String(string) => { let addr = compiler.frame_mut().closure.new_string(string); let dst = compiler.frame_mut().new_register(); compiler .frame_mut() .closure .write(ByteCode::String { dst, addr }, pos); Ok(dst) } Lege eine neue Konstante an Erstelle ein neues Register Schreibe eine Number/String Anweisung in den jetzigen Closure mit der Konstanten Adresse aus dem 1. Schritt und dem Register aus dem 2. Schritt","title":"Number und String"},{"location":"Compiler/#in-einer-funktion","text":"Das ganze packe ich noch in eine generische Funktion. pub fn compile<A: Compilable>(ast: A) -> Result<A::Output, A::Error> { ast.compile(&mut Compiler::default()) } A ist hier alles was Compiliert werden kann. Die Funktion ist eigentlich nur eine \u00dcbersetzung und benutzen tut man sie eigentlich nur mit dem Chunk AST (z.B. compile(chunk) wo chunk von Typ Located<Chunk> ist), aber ist generell eine gute Abstraktion um die Erwartung des Sprach-Level von Betrachtern zu senken. Weiter zum Interpreter","title":"In einer Funktion"},{"location":"Interpreter/","text":"Der Interpreter muss nun den Byte Code des Compilers interpretieren. Teil des Interpreters habe ich schon im Compiler Abschnitt erkl\u00e4rt, da der Compiler abh\u00e4ngig von dem Interpreter ist und anders herum auch. Beide Implementationen m\u00fcssen auf einander abgestimmt sein, sonst kommt es zu einem Fehlerhaften ausf\u00fchren und unerwarteten Problemen. Stack Ich benutze das Wort Stack im folgendem sehr oft deswegen gibt es eine kurze ChatGPT Zusammenfassung davon: In der Informatik bezeichnet ein \"Stack\" eine abstrakte Datenstruktur, die nach dem LIFO (Last In, First Out) Prinzip funktioniert. Das bedeutet, dass das zuletzt hinzugef\u00fcgte Element auch als erstes entfernt wird. Ein Stack kann als Stapel von Objekten betrachtet werden, ~~ bei dem nur das oberste Element zug\u00e4nglich ist ~~. Ein Stack unterst\u00fctzt im Allgemeinen zwei grundlegende Operationen: - Push: Dies bedeutet, ein Element oben auf den Stapel zu legen. Es wird h\u00e4ufig auch als \"Hinzuf\u00fcgen\" oder \"Einlegen\" bezeichnet. - Pop: Dies bedeutet, das oberste Element vom Stapel zu entfernen. Es wird h\u00e4ufig auch als \"Entfernen\" oder \"Herausnehmen\" bezeichnet. Neben diesen grundlegenden Operationen unterst\u00fctzt ein Stack oft auch eine dritte Operation: - Peek (auch Top genannt): Diese Operation erm\u00f6glicht es, das oberste Element des Stapels zu betrachten, ohne es zu entfernen. Stacks werden h\u00e4ufig in der Informatik verwendet, insbesondere in der Programmierung, um die Reihenfolge von Operationen zu verfolgen, wie zum Beispiel bei der Auswertung von Ausdr\u00fccken in umgekehrter polnischer Notation (Reverse Polish Notation, RPN), der Verwaltung von Funktionsaufrufen oder dem Durchlaufen von Datenstrukturen wie B\u00e4umen (zum Beispiel beim Tiefensuchalgorithmus). von: https://chat.openai.com Diese Erkl\u00e4rung ist sehr akkurat, au\u00dfer dass in meinem Fall jedes Element im Stack angeschaut werden kann, und nicht nur das oberste. Value Um alle Werte darstellen zu k\u00f6nnen f\u00fcr den Interpreter habe ich folgendes enum geschrieben: enum Value { #[default] Null, Number(f64), Boolean(bool), String(Rc<str>), Function(Rc<Function>), } enum Function { NativeFunction(NativeFunction), Function(Rc<Closure>), } type NativeFunction = fn(&mut Interpreter, Vec<Value>) -> Result<Value, Box<dyn Error>>; Null : ist ein leerer Wert, andere Sprachen nennen ihn None oder Nil. Number : eine Dezimalzahl Boolean : ein Bit der Wahr oder Falsch darstellt String : eine Referenz zu einem String Function : Eine Referenz zu einer Funktion NativeFunction : Eine in Rust geschriebene Funktion Function : Eine Referenz zu einem Closure Interpreter In meinem Interpreter benutze ich zwei Stacks: Einmal den Call Stack, und f\u00fcr jeden Call Stack noch einen Register Stack. Der Call Stack ist daf\u00fcr da sich die Funktionsaufrufe zu merken die w\u00e4hrend des Ausf\u00fchren eine Codes zu merken. Der Register Stack ist daf\u00fcr da sich die Werte von Variablen oder die Werte von Operationen zu speichern, welche relevant sind. struct Interpreter { call_stack: Vec<CallFrame>, globals: HashMap<String, Value>, } struct CallFrame { closure: Rc<Closure>, ip: Address, stack: Vec<Rc<RefCell<Value>>>, dst: Option<Register>, } Der Interpreter hat noch zus\u00e4tzlich eine Globale Umgebung (also eine Tabelle mit Identifier-Value Paaren). Ein Call Frame muss mit einer Referenz zu einem Closure nat\u00fcrlich auch einen Instruction Pointer haben, der zeigt wo im Code der Frame sich gerade befindet, den oben genannten Register Stack, wo ein Register eigentlich nur eine Zellen-Referenz zu einem Value ist, und noch ein optionales Result Register (das Zielregister aus dem vorherigen Call Frame). Errors Nat\u00fcrlich k\u00f6nnen auch Fehler w\u00e4hrend der Ausf\u00fchrung des Programs auftreten, weswegen man einen Error Typen ben\u00f6tigt. enum RunTimeError { Binary { left: &'static str, right: &'static str, }, Unary { right: &'static str, }, CannotCall(&'static str), Custome(String), } &'static str hei\u00dft so viel wie ein String der f\u00fcr das ganze Program statisch, also gleich, bleibt. In diesem Fall sind das Strings f\u00fcr die Namen der Typen, was in diesem Fall nur folgende Typen sein kann: - null - number - boolean - string - function F\u00fcr ein gute Programmiersprache fehlt definitiv noch eine Art von Kollektionstypen, wie eine Liste und/oder eine Art Objekt, auch Dictionary in Python oder Table in Lua genannt. Aber das hier ist nur eine Beispiel Sprache, also habe ich diese jetzt erst mal raus gelassen. (Aber in Luna habe ich tats\u00e4chlich beides implementiert) Implementierung Funktions Aufrufung Als erstes ist es wichtig das der Interpreter Funktionen aufrufen kann. Das hei\u00dft er braucht eine Referenz zu einem Closure, die Argumente, und ein m\u00f6gliches Result Register. fn call_closure(&mut self, closure: &Rc<Closure>, args: Vec<Value>, dst: Option<Register>) { let mut stack = Vec::with_capacity(closure.registers as usize + 1); let args = &args[0..stack.capacity().min(args.len())]; let args_len = args.len(); stack.extend(args.iter().map(|v| Rc::new(RefCell::new(v.clone())))); stack.extend( (args_len..=closure.registers as usize).map(|_| Rc::new(RefCell::new(Value::default()))), ); self.call_stack.push(CallFrame { closure: Rc::clone(closure), ip: 0, stack, dst, }); } Hier lege ich ein neues Call Frame an und f\u00fcge es dem Call Stack hinzu. Der Stack wird mit einer fixen Kapazit\u00e4t angelegt (Performance Gr\u00fcnde), dann werden die Argumente zu der Stack Kapazit\u00e4t eingeschr\u00e4nkt. Danach wird der Stack mit den Argumenten gef\u00fcllt und falls noch etwas Platz \u00fcbrig ist m\u00fcssen dort Null Values drinnen sein. Funktions Wiedergabe Um aus einer Funktion rauszukommen habe ich folgende Funktion geschrieben: pub fn return_call(&mut self, src: Option<Register>) -> Option<Value> { let top_frame = self.call_stack.pop().expect(\"no frame on stack\"); if let Some(prev_frame) = self.call_frame_mut() { if let Some(dst) = top_frame.dst { let value = if let Some(src) = src { top_frame .register(src) .expect(\"source not found\") .borrow() .clone() } else { Value::default() }; let dst = prev_frame.register(dst).expect(\"location not found\"); *dst.borrow_mut() = value; } } if let Some(src) = src { return Some( top_frame .register(src) .expect(\"source not found\") .borrow() .clone(), ); } None } Hier wird das oberste Call Frame weggenommen und geschaut ob es einen Result Register hat. Wenn das der Fall ist wird der Wert in dem src Register oder Null in das Result Register getan. Der gleiche Wert wird auch aus der Funktion wiedergegeben. Anweisungen Um in dem Program fortzuschreiten ben\u00f6tigen wir eine Funktion, die die jetzige Anweisung ausf\u00fchrt und dann zur n\u00e4chsten geht. fn run(&mut self, closure: &Rc<Closure>) -> Result<Option<Value>, Located<RunTimeError>> { let offset = self.call_stack.len(); self.call_closure(closure, vec![], None); loop { let value = self.step()?; if self.call_stack.len() <= offset || self.call_stack.is_empty() { return Ok(value); } } } Die run Funktion hier ruft die step Funktion immer wieder auf bis der Call Stack wieder die gleich Gr\u00f6\u00dfe hat wie vor dem Aufrufen oder 0 hat, sprich er ist leer. Da ein Wert wiedergegeben werden kann wird der letzte Wert der step Funktion daf\u00fcr genommen fn step(&mut self) -> Result<Option<Value>, Located<RunTimeError>> { let Located { value: bytecode, pos, } = self .call_frame() .expect(\"no call frame on stack\") .instr() .expect(\"ip out of range\") .clone(); self.call_frame_mut().expect(\"no call frame on stack\").ip += 1; // advance the instruction pointer match bytecode { ... } Ok(None) } Hier wird die momentane Anweisung genommen und der Instruction Pointer um eins erh\u00f6ht. Die genommene Anweisung muss dann nur noch bearbeitet werden in einem match Zweig. None ByteCode::None => {} Macht nichts... Jump ByteCode::Jump { addr } => { self.call_frame_mut().expect(\"no call frame on stack\").ip = addr; } Setzt den Instruction Pointer auf die Adresse Jump If ByteCode::JumpIf { not: false, cond, addr, } => { let cond = self .register(cond) .expect(\"register not found\") .borrow() .clone(); if bool::from(&cond) { self.call_frame_mut().expect(\"no call frame on stack\").ip = addr; } } ByteCode::JumpIf { not: true, cond, addr, } => { let cond = self .register(cond) .expect(\"register not found\") .borrow() .clone(); if !bool::from(&cond) { self.call_frame_mut().expect(\"no call frame on stack\").ip = addr; } } Nimmt den Wert in dem cond Register, wandelt ihn in ein Boolean um und setzt den Instruction Pointer auf die Adresse. Das not verneint den booleschen Wert nat\u00fcrlich. Call ByteCode::Call { func, offset, args_len, dst, } => { let func = self .register(func) .expect(\"register not found\") .borrow() .clone(); let mut args: Vec<Value> = Vec::with_capacity(args_len as usize); args.extend((offset..offset + args_len as Register).map(|reg| { self.register(reg) .expect(\"register not found\") .borrow() .clone() })); match func { Value::Function(function) => { self.call(&function, args, &pos, dst) .map_err(|err| err.map(|err| RunTimeError::Custome(err.to_string())))?; } value => return Err(Located::new(RunTimeError::CannotCall(value.typ()), pos)), } } Nimmt den Wert in dem func Register, sammelt die Argumente aus den Registern und ruft die Funktion auf wenn von Typ function ist, sonst gibt er einen RunTimeError wieder. Return ByteCode::Return { src } => return Ok(self.return_call(src)), Gibt den Wert aus dem src Register wieder wenn es gegeben ist. Move ByteCode::Move { dst, src } => { let src = self .register(src) .expect(\"register not found\") .borrow() .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = src; } Kopiert den Wert aus dem src Register und setzt den Wert des dst Register darauf. String und Number ByteCode::String { dst, addr } => { let string = self .call_frame() .expect(\"no call frame on stack\") .closure .string(addr) .expect(\"string not found\") .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = Value::String(string.into()); } ByteCode::Number { dst, addr } => { let number = self .call_frame() .expect(\"no call frame on stack\") .closure .number(addr) .expect(\"number not found\") .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = Value::Number(number); } Kopiert den konstanten Wert aus dem jeweiligen Konstanten Pool und setzt das dst Register auf diesen Wert (umgewandelt in ein Value nat\u00fcrlich) Closure ByteCode::Closure { dst, addr } => { let closure = Rc::clone( self.call_frame() .expect(\"no call frame on stack\") .closure .closure(addr) .expect(\"closure not found\"), ); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = Value::Function(Rc::new(Function::Function(closure))); } Erstellt eine neue Referenz zu dem Closure aus dem Closure Konstanten Pool und setzt das dst Register auf diesen Wert in Form einer Funktion Global ByteCode::Global { dst, addr } => { let value = { let string = self .call_frame() .expect(\"no call frame on stack\") .closure .string(addr) .expect(\"string not found\"); self.globals.get(string).cloned().unwrap_or_default() }; let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = value; } Kopiert den Wert aus der Globalen Umgebung von dem String des String Konstanten Pools und setzt das dst Register auf diesen Wert. Set Global ByteCode::SetGlobal { addr, src } => { let value = self.register(src).expect(\"register not found\").borrow().clone(); let ident = self .call_frame() .expect(\"no call frame on stack\") .closure .string(addr) .expect(\"string not found\") .clone(); let old_value = { self.globals.get_mut(&ident) }; if let Some(old_value) = old_value { *old_value = value; } else { self.globals.insert(ident, value); } } Nimmt den Wert aus der Globalen Umgebung von dem String des String Konstanten Pools und setzt diesen Wert auf den Wert aus dem src Register. Falls der Eintrag in der Globalen Umgebung nicht existiert, wird ein neuer Eintrag erstellt mit dem Wert aus dem src Register. Binary ByteCode::Binary { op, dst, left, right, } => { let left = self .register(left) .expect(\"register not found\") .borrow() .clone(); let right = self .register(right) .expect(\"register not found\") .borrow() .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = match op { ... }; } Nimmt die Werte aus den left Register und right Register, f\u00fchrt die Binary Operation aus, und setzt den Wert in dem dst Register auf das Ergebnis. Binary ByteCode::Unary { op, dst, src } => { let right = self .register(src) .expect(\"register not found\") .borrow() .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = match op { ... }; } Nimmt den Wert aus dem right Register, f\u00fchrt die Unary Operation aus, und setzt den Wert in dem dst Register auf das Ergebnis. Globale Funktionen Die Programmiersprache funktioniert schon ganz gut, dennoch kann man nicht viel damit interagieren. Zum Beispiel fehlen Funktionen wie print . Deswegen m\u00fcssen vor dem Start des Interpretierens globale Funktionen erstellt werden. fn run(closure: &Rc<Closure>) -> Result<Option<Value>, Located<RunTimeError>> { let mut interpreter = Interpreter::default(); std_globals(&mut interpreter.globals); interpreter.run(closure) } fn std_globals(globals: &mut HashMap<String, Value>) { globals.insert( \"print\".into(), Value::Function(Rc::new(Function::NativeFunction(_print))), ); } fn _print(_: &mut Interpreter, args: Vec<Value>) -> Result<Value, Box<dyn Error>> { for arg in args { print!(\"{}\", arg); } println!(); Ok(Value::default()) } Die run Funktion nimmt ein Closure, erstellt einen Interpreter, l\u00e4sst std_globals standard globale Variablen erstellen, und f\u00fchrt den Code aus. Hier habe ich die print Funktion definiert dammit man endlich ein Hello World! -Program schreiben kann. print(\"Hello World!\")","title":"Interpreter"},{"location":"Interpreter/#stack","text":"Ich benutze das Wort Stack im folgendem sehr oft deswegen gibt es eine kurze ChatGPT Zusammenfassung davon: In der Informatik bezeichnet ein \"Stack\" eine abstrakte Datenstruktur, die nach dem LIFO (Last In, First Out) Prinzip funktioniert. Das bedeutet, dass das zuletzt hinzugef\u00fcgte Element auch als erstes entfernt wird. Ein Stack kann als Stapel von Objekten betrachtet werden, ~~ bei dem nur das oberste Element zug\u00e4nglich ist ~~. Ein Stack unterst\u00fctzt im Allgemeinen zwei grundlegende Operationen: - Push: Dies bedeutet, ein Element oben auf den Stapel zu legen. Es wird h\u00e4ufig auch als \"Hinzuf\u00fcgen\" oder \"Einlegen\" bezeichnet. - Pop: Dies bedeutet, das oberste Element vom Stapel zu entfernen. Es wird h\u00e4ufig auch als \"Entfernen\" oder \"Herausnehmen\" bezeichnet. Neben diesen grundlegenden Operationen unterst\u00fctzt ein Stack oft auch eine dritte Operation: - Peek (auch Top genannt): Diese Operation erm\u00f6glicht es, das oberste Element des Stapels zu betrachten, ohne es zu entfernen. Stacks werden h\u00e4ufig in der Informatik verwendet, insbesondere in der Programmierung, um die Reihenfolge von Operationen zu verfolgen, wie zum Beispiel bei der Auswertung von Ausdr\u00fccken in umgekehrter polnischer Notation (Reverse Polish Notation, RPN), der Verwaltung von Funktionsaufrufen oder dem Durchlaufen von Datenstrukturen wie B\u00e4umen (zum Beispiel beim Tiefensuchalgorithmus). von: https://chat.openai.com Diese Erkl\u00e4rung ist sehr akkurat, au\u00dfer dass in meinem Fall jedes Element im Stack angeschaut werden kann, und nicht nur das oberste.","title":"Stack"},{"location":"Interpreter/#value","text":"Um alle Werte darstellen zu k\u00f6nnen f\u00fcr den Interpreter habe ich folgendes enum geschrieben: enum Value { #[default] Null, Number(f64), Boolean(bool), String(Rc<str>), Function(Rc<Function>), } enum Function { NativeFunction(NativeFunction), Function(Rc<Closure>), } type NativeFunction = fn(&mut Interpreter, Vec<Value>) -> Result<Value, Box<dyn Error>>; Null : ist ein leerer Wert, andere Sprachen nennen ihn None oder Nil. Number : eine Dezimalzahl Boolean : ein Bit der Wahr oder Falsch darstellt String : eine Referenz zu einem String Function : Eine Referenz zu einer Funktion NativeFunction : Eine in Rust geschriebene Funktion Function : Eine Referenz zu einem Closure","title":"Value"},{"location":"Interpreter/#interpreter","text":"In meinem Interpreter benutze ich zwei Stacks: Einmal den Call Stack, und f\u00fcr jeden Call Stack noch einen Register Stack. Der Call Stack ist daf\u00fcr da sich die Funktionsaufrufe zu merken die w\u00e4hrend des Ausf\u00fchren eine Codes zu merken. Der Register Stack ist daf\u00fcr da sich die Werte von Variablen oder die Werte von Operationen zu speichern, welche relevant sind. struct Interpreter { call_stack: Vec<CallFrame>, globals: HashMap<String, Value>, } struct CallFrame { closure: Rc<Closure>, ip: Address, stack: Vec<Rc<RefCell<Value>>>, dst: Option<Register>, } Der Interpreter hat noch zus\u00e4tzlich eine Globale Umgebung (also eine Tabelle mit Identifier-Value Paaren). Ein Call Frame muss mit einer Referenz zu einem Closure nat\u00fcrlich auch einen Instruction Pointer haben, der zeigt wo im Code der Frame sich gerade befindet, den oben genannten Register Stack, wo ein Register eigentlich nur eine Zellen-Referenz zu einem Value ist, und noch ein optionales Result Register (das Zielregister aus dem vorherigen Call Frame).","title":"Interpreter"},{"location":"Interpreter/#errors","text":"Nat\u00fcrlich k\u00f6nnen auch Fehler w\u00e4hrend der Ausf\u00fchrung des Programs auftreten, weswegen man einen Error Typen ben\u00f6tigt. enum RunTimeError { Binary { left: &'static str, right: &'static str, }, Unary { right: &'static str, }, CannotCall(&'static str), Custome(String), } &'static str hei\u00dft so viel wie ein String der f\u00fcr das ganze Program statisch, also gleich, bleibt. In diesem Fall sind das Strings f\u00fcr die Namen der Typen, was in diesem Fall nur folgende Typen sein kann: - null - number - boolean - string - function F\u00fcr ein gute Programmiersprache fehlt definitiv noch eine Art von Kollektionstypen, wie eine Liste und/oder eine Art Objekt, auch Dictionary in Python oder Table in Lua genannt. Aber das hier ist nur eine Beispiel Sprache, also habe ich diese jetzt erst mal raus gelassen. (Aber in Luna habe ich tats\u00e4chlich beides implementiert)","title":"Errors"},{"location":"Interpreter/#implementierung","text":"","title":"Implementierung"},{"location":"Interpreter/#funktions-aufrufung","text":"Als erstes ist es wichtig das der Interpreter Funktionen aufrufen kann. Das hei\u00dft er braucht eine Referenz zu einem Closure, die Argumente, und ein m\u00f6gliches Result Register. fn call_closure(&mut self, closure: &Rc<Closure>, args: Vec<Value>, dst: Option<Register>) { let mut stack = Vec::with_capacity(closure.registers as usize + 1); let args = &args[0..stack.capacity().min(args.len())]; let args_len = args.len(); stack.extend(args.iter().map(|v| Rc::new(RefCell::new(v.clone())))); stack.extend( (args_len..=closure.registers as usize).map(|_| Rc::new(RefCell::new(Value::default()))), ); self.call_stack.push(CallFrame { closure: Rc::clone(closure), ip: 0, stack, dst, }); } Hier lege ich ein neues Call Frame an und f\u00fcge es dem Call Stack hinzu. Der Stack wird mit einer fixen Kapazit\u00e4t angelegt (Performance Gr\u00fcnde), dann werden die Argumente zu der Stack Kapazit\u00e4t eingeschr\u00e4nkt. Danach wird der Stack mit den Argumenten gef\u00fcllt und falls noch etwas Platz \u00fcbrig ist m\u00fcssen dort Null Values drinnen sein.","title":"Funktions Aufrufung"},{"location":"Interpreter/#funktions-wiedergabe","text":"Um aus einer Funktion rauszukommen habe ich folgende Funktion geschrieben: pub fn return_call(&mut self, src: Option<Register>) -> Option<Value> { let top_frame = self.call_stack.pop().expect(\"no frame on stack\"); if let Some(prev_frame) = self.call_frame_mut() { if let Some(dst) = top_frame.dst { let value = if let Some(src) = src { top_frame .register(src) .expect(\"source not found\") .borrow() .clone() } else { Value::default() }; let dst = prev_frame.register(dst).expect(\"location not found\"); *dst.borrow_mut() = value; } } if let Some(src) = src { return Some( top_frame .register(src) .expect(\"source not found\") .borrow() .clone(), ); } None } Hier wird das oberste Call Frame weggenommen und geschaut ob es einen Result Register hat. Wenn das der Fall ist wird der Wert in dem src Register oder Null in das Result Register getan. Der gleiche Wert wird auch aus der Funktion wiedergegeben.","title":"Funktions Wiedergabe"},{"location":"Interpreter/#anweisungen","text":"Um in dem Program fortzuschreiten ben\u00f6tigen wir eine Funktion, die die jetzige Anweisung ausf\u00fchrt und dann zur n\u00e4chsten geht. fn run(&mut self, closure: &Rc<Closure>) -> Result<Option<Value>, Located<RunTimeError>> { let offset = self.call_stack.len(); self.call_closure(closure, vec![], None); loop { let value = self.step()?; if self.call_stack.len() <= offset || self.call_stack.is_empty() { return Ok(value); } } } Die run Funktion hier ruft die step Funktion immer wieder auf bis der Call Stack wieder die gleich Gr\u00f6\u00dfe hat wie vor dem Aufrufen oder 0 hat, sprich er ist leer. Da ein Wert wiedergegeben werden kann wird der letzte Wert der step Funktion daf\u00fcr genommen fn step(&mut self) -> Result<Option<Value>, Located<RunTimeError>> { let Located { value: bytecode, pos, } = self .call_frame() .expect(\"no call frame on stack\") .instr() .expect(\"ip out of range\") .clone(); self.call_frame_mut().expect(\"no call frame on stack\").ip += 1; // advance the instruction pointer match bytecode { ... } Ok(None) } Hier wird die momentane Anweisung genommen und der Instruction Pointer um eins erh\u00f6ht. Die genommene Anweisung muss dann nur noch bearbeitet werden in einem match Zweig.","title":"Anweisungen"},{"location":"Interpreter/#none","text":"ByteCode::None => {} Macht nichts...","title":"None"},{"location":"Interpreter/#jump","text":"ByteCode::Jump { addr } => { self.call_frame_mut().expect(\"no call frame on stack\").ip = addr; } Setzt den Instruction Pointer auf die Adresse","title":"Jump"},{"location":"Interpreter/#jump-if","text":"ByteCode::JumpIf { not: false, cond, addr, } => { let cond = self .register(cond) .expect(\"register not found\") .borrow() .clone(); if bool::from(&cond) { self.call_frame_mut().expect(\"no call frame on stack\").ip = addr; } } ByteCode::JumpIf { not: true, cond, addr, } => { let cond = self .register(cond) .expect(\"register not found\") .borrow() .clone(); if !bool::from(&cond) { self.call_frame_mut().expect(\"no call frame on stack\").ip = addr; } } Nimmt den Wert in dem cond Register, wandelt ihn in ein Boolean um und setzt den Instruction Pointer auf die Adresse. Das not verneint den booleschen Wert nat\u00fcrlich.","title":"Jump If"},{"location":"Interpreter/#call","text":"ByteCode::Call { func, offset, args_len, dst, } => { let func = self .register(func) .expect(\"register not found\") .borrow() .clone(); let mut args: Vec<Value> = Vec::with_capacity(args_len as usize); args.extend((offset..offset + args_len as Register).map(|reg| { self.register(reg) .expect(\"register not found\") .borrow() .clone() })); match func { Value::Function(function) => { self.call(&function, args, &pos, dst) .map_err(|err| err.map(|err| RunTimeError::Custome(err.to_string())))?; } value => return Err(Located::new(RunTimeError::CannotCall(value.typ()), pos)), } } Nimmt den Wert in dem func Register, sammelt die Argumente aus den Registern und ruft die Funktion auf wenn von Typ function ist, sonst gibt er einen RunTimeError wieder.","title":"Call"},{"location":"Interpreter/#return","text":"ByteCode::Return { src } => return Ok(self.return_call(src)), Gibt den Wert aus dem src Register wieder wenn es gegeben ist.","title":"Return"},{"location":"Interpreter/#move","text":"ByteCode::Move { dst, src } => { let src = self .register(src) .expect(\"register not found\") .borrow() .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = src; } Kopiert den Wert aus dem src Register und setzt den Wert des dst Register darauf.","title":"Move"},{"location":"Interpreter/#string-und-number","text":"ByteCode::String { dst, addr } => { let string = self .call_frame() .expect(\"no call frame on stack\") .closure .string(addr) .expect(\"string not found\") .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = Value::String(string.into()); } ByteCode::Number { dst, addr } => { let number = self .call_frame() .expect(\"no call frame on stack\") .closure .number(addr) .expect(\"number not found\") .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = Value::Number(number); } Kopiert den konstanten Wert aus dem jeweiligen Konstanten Pool und setzt das dst Register auf diesen Wert (umgewandelt in ein Value nat\u00fcrlich)","title":"String und Number"},{"location":"Interpreter/#closure","text":"ByteCode::Closure { dst, addr } => { let closure = Rc::clone( self.call_frame() .expect(\"no call frame on stack\") .closure .closure(addr) .expect(\"closure not found\"), ); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = Value::Function(Rc::new(Function::Function(closure))); } Erstellt eine neue Referenz zu dem Closure aus dem Closure Konstanten Pool und setzt das dst Register auf diesen Wert in Form einer Funktion","title":"Closure"},{"location":"Interpreter/#global","text":"ByteCode::Global { dst, addr } => { let value = { let string = self .call_frame() .expect(\"no call frame on stack\") .closure .string(addr) .expect(\"string not found\"); self.globals.get(string).cloned().unwrap_or_default() }; let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = value; } Kopiert den Wert aus der Globalen Umgebung von dem String des String Konstanten Pools und setzt das dst Register auf diesen Wert.","title":"Global"},{"location":"Interpreter/#set-global","text":"ByteCode::SetGlobal { addr, src } => { let value = self.register(src).expect(\"register not found\").borrow().clone(); let ident = self .call_frame() .expect(\"no call frame on stack\") .closure .string(addr) .expect(\"string not found\") .clone(); let old_value = { self.globals.get_mut(&ident) }; if let Some(old_value) = old_value { *old_value = value; } else { self.globals.insert(ident, value); } } Nimmt den Wert aus der Globalen Umgebung von dem String des String Konstanten Pools und setzt diesen Wert auf den Wert aus dem src Register. Falls der Eintrag in der Globalen Umgebung nicht existiert, wird ein neuer Eintrag erstellt mit dem Wert aus dem src Register.","title":"Set Global"},{"location":"Interpreter/#binary","text":"ByteCode::Binary { op, dst, left, right, } => { let left = self .register(left) .expect(\"register not found\") .borrow() .clone(); let right = self .register(right) .expect(\"register not found\") .borrow() .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = match op { ... }; } Nimmt die Werte aus den left Register und right Register, f\u00fchrt die Binary Operation aus, und setzt den Wert in dem dst Register auf das Ergebnis.","title":"Binary"},{"location":"Interpreter/#binary_1","text":"ByteCode::Unary { op, dst, src } => { let right = self .register(src) .expect(\"register not found\") .borrow() .clone(); let mut dst = self.register(dst).expect(\"register not found\").borrow_mut(); *dst = match op { ... }; } Nimmt den Wert aus dem right Register, f\u00fchrt die Unary Operation aus, und setzt den Wert in dem dst Register auf das Ergebnis.","title":"Binary"},{"location":"Interpreter/#globale-funktionen","text":"Die Programmiersprache funktioniert schon ganz gut, dennoch kann man nicht viel damit interagieren. Zum Beispiel fehlen Funktionen wie print . Deswegen m\u00fcssen vor dem Start des Interpretierens globale Funktionen erstellt werden. fn run(closure: &Rc<Closure>) -> Result<Option<Value>, Located<RunTimeError>> { let mut interpreter = Interpreter::default(); std_globals(&mut interpreter.globals); interpreter.run(closure) } fn std_globals(globals: &mut HashMap<String, Value>) { globals.insert( \"print\".into(), Value::Function(Rc::new(Function::NativeFunction(_print))), ); } fn _print(_: &mut Interpreter, args: Vec<Value>) -> Result<Value, Box<dyn Error>> { for arg in args { print!(\"{}\", arg); } println!(); Ok(Value::default()) } Die run Funktion nimmt ein Closure, erstellt einen Interpreter, l\u00e4sst std_globals standard globale Variablen erstellen, und f\u00fchrt den Code aus. Hier habe ich die print Funktion definiert dammit man endlich ein Hello World! -Program schreiben kann. print(\"Hello World!\")","title":"Globale Funktionen"},{"location":"Lexer/","text":"Der Lexer f\u00fchrt eine lexikalische Analyse des Input-Texts durch, wobei er Buchstaben in Symbolen, Schl\u00fcsselw\u00f6rtern, oder Zahlen zusammenfasst. Diese nennt man Token (Englisch f\u00fcr \"Zeichen\" oder \"Symbol\"). Diese helfen uns sp\u00e4ter um eine bessere syntaktische Analyse mit dem Parser zu vollf\u00fchren. Tokens Um Tokens repr\u00e4sentieren zu k\u00f6nnen benutze ich in Rust ein sogenanntes enum . Dieser Typ von Datenstruktur erlaubt es einem seinen eigenen Datentypen zu erstellen, der beliebig viele Varianten haben kann. pub enum Token { // word kinds Ident(String), Number(f64), String(String), ... } Hier habe ich nun die ersten Varianten eines Tokens in meiner Sprache definiert: - Ident : Kurz f\u00fcr \"identifier\", ein einfaches Wort ohne jetzige Bedeutung - Number : Eine Dezimalzahl ( f64 : floating point number mit einer Bit-Gr\u00f6\u00dfe von 64) - String : Eine Buchstaben folge von beliebiger Gr\u00f6\u00dfe pub enum Token { ... // symbols Equal, // = Comma, // , Dot, // . ParanLeft, // ( ParanRight, // ) BracketLeft, // [ BracketRight, // ] BraceLeft, // { BraceRight, // } Plus, // + Minus, // - Star, // * Slash, // / Percent, // % Exponent, // ^ EqualEqual, // == ExclamationEqual, // != Less, // < Greater, // > LessEqual, // <= GreaterEqual, // >= Ampersand, // & Pipe, // | Exclamation, // ! ... } Als n\u00e4chstes habe ich hier verschiedene Symbole definiert die sp\u00e4ter gut zu gebrauchen sind. pub enum Token { ... // key words Let, Def, If, Else, While, For, } Zum Schluss habe ich hier noch ein paar Schl\u00fcsselw\u00f6rter definiert. Position Um die Tokens sp\u00e4ter f\u00fcr die Fehlerbehandlung lokalisieren zu k\u00f6nnen im Text habe ich zwei Spezielle Datentypen erstellt, die ich sp\u00e4ter dauernd benutzen werde. struct Position { ln: usize, col: usize, } struct Located<T> { value: T, pos: Position, } Position ist eine Struktur, die die Zeilen- und Spaltennummer sich merkt in Form von zwei usize (eine ganze Zahl die nicht negativ sein kann). Located<T> ist eine generalisierte Struktur, die einen Wert ( value ) eines beliebigen Datentypen ( T ) und eine Position ( pos ) zusammen speichert. Um die Tokens zu Lokalisieren benutze ich oft die Variante Located<Token> , was bedeutet, dass die schlussendliche Struktur daf\u00fcr wie folgt aussieht: struct Located<Token> { value: Token, pos: Position } T wird hier zu Token . Located<T> ist also keine eigene Struktur, sondern ist lediglich eine Vorlage f\u00fcr eine echte Struktur. Lexer Der Lexer wird nun wie folgt implementiert: struct Lexer<'a> { chars: Peekable<Chars<'a>>, // Iterator \u00fcber einen Text ln: usize, // Zeilennummer col: usize, // Spaltennummer } Die Struktur Lexer besteht aus dem Feld chars , welche ein Iterator \u00fcber char ist, und einer Zeilennummer ( ln ) sowie einer Spaltennummer ( col ). Das sind alle Daten, die man ben\u00f6tigen um erfolgreich Tokens zu generieren. impl<'a> Iterator for Lexer<'a> { type Item = char; fn next(&mut self) -> Option<Self::Item> { let c = self.chars.next()?; // n\u00e4chster Buchstabe if c == '\\n' { // neue Zeile self.ln += 1; self.col = 0; } else { self.col += 1; } Some(c) // gibt den Buchtstaben wider } } Um noch mehr Funktionalit\u00e4ten f\u00fcr den Lexer zu implementieren, benutzen wir den Iterator Trait in Rust. Dieser ben\u00f6tigt nur eine Funktion next und den Typen des Widergabewertes Item was in unserem Fall char ist. Rust erstellt dann automatisch noch mehr Funktionen f\u00fcr den Lexer, da diese nur die next Funktion ben\u00f6tigen. trait Lexable: Sized { type Error; fn lex_next<'a>(lexer: &mut Lexer<'a>) -> Result<Option<Located<Self>>, Located<Self::Error>>; fn lex(text: &str) -> Result<Vec<Located<Self>>, Located<Self::Error>> { let mut lexer = Lexer { chars: text.chars().peekable(), ln: 0, col: 0 }; let mut tokens = vec![]; while let Some(token) = Self::lex_next(&mut lexer)? { tokens.push(token) } Ok(tokens) } } Hier definiere ich einen eigenen Trait namens Lexable . Das einzige was hier wichtig ist zu verstehen ist, dass Traits f\u00fcr jeglichen Datentypen Implementiert werden k\u00f6nnen mit impl Trait for Type { ... } , und dass dieser Lexable Trait den Implementierer zwingt die lex_next Funktion und den Error Typen zu definieren. enum LexError { BadCharacter(char), ParseNumberError(ParseFloatError), UnclosedString, } impl Lexable for Token { type Error = LexError; fn lex_next<'a>(lexer: &mut Lexer<'a>) -> Result<Option<Located<Self>>, Located<Self::Error>> { ... } } Genau das mache ich hier f\u00fcr Token . Dort wo die drei Punkte sind werde ich in folge die [[#Schritte des Lexers]]. LexError ist ein enum um alle Fehler die entstehen k\u00f6nnen beim Lexen darzustellen. Schritte des Lexers Leerzeichen while let Some(c) = lexer.peek() { if !c.is_ascii_whitespace() { break; } lexer.next(); } let pos = lexer.pos(); let Some(c) = lexer.next() else { return Ok(None); }; ... Als erstes ist es wichtig alle Leerzeichen (dazu z\u00e4hlen auch Zeilenumbr\u00fcche) zu \u00fcberspringen, damit diese beliebig zwischen jedem Token stehen k\u00f6nnen. Daf\u00fcr ist die while let Schleife da. Danach merkt sicher der Lexer die Position un den ersten Buchstaben des zu lexendem Tokens. Symbole match c { '=' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::EqualEqual, pos))) } else { Ok(Some(Located::new(Token::Equal, pos))) } } ',' => Ok(Some(Located::new(Token::Comma, pos))), '.' => Ok(Some(Located::new(Token::Dot, pos))), '(' => Ok(Some(Located::new(Token::ParanLeft, pos))), ')' => Ok(Some(Located::new(Token::ParanRight, pos))), '[' => Ok(Some(Located::new(Token::BracketLeft, pos))), ']' => Ok(Some(Located::new(Token::BracketRight, pos))), '{' => Ok(Some(Located::new(Token::BraceLeft, pos))), '}' => Ok(Some(Located::new(Token::BraceRight, pos))), '+' => Ok(Some(Located::new(Token::Plus, pos))), '-' => Ok(Some(Located::new(Token::Minus, pos))), '*' => Ok(Some(Located::new(Token::Star, pos))), '/' => Ok(Some(Located::new(Token::Slash, pos))), '%' => Ok(Some(Located::new(Token::Percent, pos))), '^' => Ok(Some(Located::new(Token::Exponent, pos))), '<' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::LessEqual, pos))) } else { Ok(Some(Located::new(Token::Less, pos))) } } '>' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::GreaterEqual, pos))) } else { Ok(Some(Located::new(Token::Greater, pos))) } } '&' => Ok(Some(Located::new(Token::Ampersand, pos))), '|' => Ok(Some(Located::new(Token::Pipe, pos))), '!' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::ExclamationEqual, pos))) } else { Ok(Some(Located::new(Token::Exclamation, pos))) } } ... } Als erstes wird geschaut ob der Buchstabe ein bestimmtes Zeichen ist was f\u00fcr die Sprache von Bedeutung ist wie = oder + usw. Falls das der Fall ist geben wir einfach das Symbol als Token wider. Wie man sehen kann benutze ich daf\u00fcr den match Zweig, der in Rust ein sogenanntes Pattern-Matching (Mustervergleichen) benutzt um die Art des Buchstabens zu ermitteln. Es ist ein sehr n\u00fctzlicher Zweig, den ich immer wieder benutze, auch sp\u00e4ter. Strings match c { ... '\"' => { let mut string = String::new(); while let Some(c) = lexer.peek() { if *c == '\"' { break; } string.push(lexer.next().unwrap()) } if lexer.next() != Some('\"') { return Err(Located::new(LexError::UnclosedString, pos)) } Ok(Some(Located::new(Token::String(string), pos))) } ... } Ein spezielles Symbol f\u00fcr die Sprache ist das Anf\u00fchrungszeichen, denn zwei von diesen umgeben immer einen String. Das hei\u00dft wenn der Lexer eines begegnet, sammelt er alle Buchstaben bis er das n\u00e4chste Anf\u00fchrungszeichen hat, und dann gibt er diesen String als Token wider. Zahlen match c { ... c if c.is_ascii_digit() => { let mut number = String::from(c); while let Some(c) = lexer.peek() { if !c.is_ascii_digit() { break; } number.push(lexer.next().unwrap()) } if lexer.peek() == Some(&'.') { number.push(lexer.next().unwrap()); while let Some(c) = lexer.peek() { if !c.is_ascii_digit() { break; } number.push(lexer.next().unwrap()) } } Ok(Some(Located::new( Token::Number( number .parse() .map_err(LexError::ParseNumberError) .map_err(|err| Located::new(err, pos.clone()))?, ), pos, ))) } ... } Zahlen werden auf diese Weise gefunden. Wenn der Buchstabe eine ASCII Nummer ist werden alle darauf folgenden ASCII Nummern erst in einem String gesammelt, der dann am Ende in eine Dezimalzahl umgewandelt wird. Falls der Lexer einem Punkt begegnet nimmt er diesen mit und sammelt noch alle Nummern die danach kommen auf. Identifiers match c { ... c if c.is_alphanumeric() || c == '_' => { let mut ident = String::from(c); while let Some(c) = lexer.peek() { if !c.is_alphanumeric() && *c != '_' { break; } ident.push(lexer.next().unwrap()) } Ok(Some(Located::new(Token::ident(ident), pos))) } ... } Identifier werden auf die gleiche Art wie Zahlen aufgenommen, nur kann es hier keinen Punkt geben, was es noch einfacherer macht. Teile eines Identifiers sind alle Alpha-nummerische Buchstaben sowie Unterstriche. impl Token { ... fn ident(ident: String) -> Self { match ident.as_str() { \"let\" => Self::Let, \"def\" => Self::Def, \"if\" => Self::If, \"else\" => Self::Else, \"while\" => Self::While, \"for\" => Self::For, _ => Self::Ident(ident), } } ... } Falls der Identifier einen der Schl\u00fcsselw\u00f6rter entspricht, wird das Schl\u00fcsselwort wider gegeben und nicht der eigentliche Identifier. Errors match c { ... c => Err(Located::new(LexError::BadCharacter(c), pos)), } Wenn keiner der vorherigen Muster gepasst hat, gibt der Lexer einen Fehler wider, der besagt, dass ein nicht erkennbarer Buchstabe in dem Input ist, und schlie\u00dft somit das Programm. Sammeln fn lex(text: &str) -> Result<Vec<Located<Token>>, Located<LexError>> { let mut lexer = Lexer { chars: text.chars().peekable(), ln: 0, col: 0 }; let mut tokens = vec![]; while let Some(token) = Token::lex_next(&mut lexer)? { tokens.push(token) } Ok(tokens) } Diese Funktion f\u00fchrt die Beschrieben Schritte immer wieder aus bis es am Ende des Inputs angekommen ist. Somit erhalten wir am Ende eine Liste mit Tokens und k\u00f6nnen nun weiter mit dem Parsing machen. Weiter zum Parser .","title":"Lexer"},{"location":"Lexer/#tokens","text":"Um Tokens repr\u00e4sentieren zu k\u00f6nnen benutze ich in Rust ein sogenanntes enum . Dieser Typ von Datenstruktur erlaubt es einem seinen eigenen Datentypen zu erstellen, der beliebig viele Varianten haben kann. pub enum Token { // word kinds Ident(String), Number(f64), String(String), ... } Hier habe ich nun die ersten Varianten eines Tokens in meiner Sprache definiert: - Ident : Kurz f\u00fcr \"identifier\", ein einfaches Wort ohne jetzige Bedeutung - Number : Eine Dezimalzahl ( f64 : floating point number mit einer Bit-Gr\u00f6\u00dfe von 64) - String : Eine Buchstaben folge von beliebiger Gr\u00f6\u00dfe pub enum Token { ... // symbols Equal, // = Comma, // , Dot, // . ParanLeft, // ( ParanRight, // ) BracketLeft, // [ BracketRight, // ] BraceLeft, // { BraceRight, // } Plus, // + Minus, // - Star, // * Slash, // / Percent, // % Exponent, // ^ EqualEqual, // == ExclamationEqual, // != Less, // < Greater, // > LessEqual, // <= GreaterEqual, // >= Ampersand, // & Pipe, // | Exclamation, // ! ... } Als n\u00e4chstes habe ich hier verschiedene Symbole definiert die sp\u00e4ter gut zu gebrauchen sind. pub enum Token { ... // key words Let, Def, If, Else, While, For, } Zum Schluss habe ich hier noch ein paar Schl\u00fcsselw\u00f6rter definiert.","title":"Tokens"},{"location":"Lexer/#position","text":"Um die Tokens sp\u00e4ter f\u00fcr die Fehlerbehandlung lokalisieren zu k\u00f6nnen im Text habe ich zwei Spezielle Datentypen erstellt, die ich sp\u00e4ter dauernd benutzen werde. struct Position { ln: usize, col: usize, } struct Located<T> { value: T, pos: Position, } Position ist eine Struktur, die die Zeilen- und Spaltennummer sich merkt in Form von zwei usize (eine ganze Zahl die nicht negativ sein kann). Located<T> ist eine generalisierte Struktur, die einen Wert ( value ) eines beliebigen Datentypen ( T ) und eine Position ( pos ) zusammen speichert. Um die Tokens zu Lokalisieren benutze ich oft die Variante Located<Token> , was bedeutet, dass die schlussendliche Struktur daf\u00fcr wie folgt aussieht: struct Located<Token> { value: Token, pos: Position } T wird hier zu Token . Located<T> ist also keine eigene Struktur, sondern ist lediglich eine Vorlage f\u00fcr eine echte Struktur.","title":"Position"},{"location":"Lexer/#lexer","text":"Der Lexer wird nun wie folgt implementiert: struct Lexer<'a> { chars: Peekable<Chars<'a>>, // Iterator \u00fcber einen Text ln: usize, // Zeilennummer col: usize, // Spaltennummer } Die Struktur Lexer besteht aus dem Feld chars , welche ein Iterator \u00fcber char ist, und einer Zeilennummer ( ln ) sowie einer Spaltennummer ( col ). Das sind alle Daten, die man ben\u00f6tigen um erfolgreich Tokens zu generieren. impl<'a> Iterator for Lexer<'a> { type Item = char; fn next(&mut self) -> Option<Self::Item> { let c = self.chars.next()?; // n\u00e4chster Buchstabe if c == '\\n' { // neue Zeile self.ln += 1; self.col = 0; } else { self.col += 1; } Some(c) // gibt den Buchtstaben wider } } Um noch mehr Funktionalit\u00e4ten f\u00fcr den Lexer zu implementieren, benutzen wir den Iterator Trait in Rust. Dieser ben\u00f6tigt nur eine Funktion next und den Typen des Widergabewertes Item was in unserem Fall char ist. Rust erstellt dann automatisch noch mehr Funktionen f\u00fcr den Lexer, da diese nur die next Funktion ben\u00f6tigen. trait Lexable: Sized { type Error; fn lex_next<'a>(lexer: &mut Lexer<'a>) -> Result<Option<Located<Self>>, Located<Self::Error>>; fn lex(text: &str) -> Result<Vec<Located<Self>>, Located<Self::Error>> { let mut lexer = Lexer { chars: text.chars().peekable(), ln: 0, col: 0 }; let mut tokens = vec![]; while let Some(token) = Self::lex_next(&mut lexer)? { tokens.push(token) } Ok(tokens) } } Hier definiere ich einen eigenen Trait namens Lexable . Das einzige was hier wichtig ist zu verstehen ist, dass Traits f\u00fcr jeglichen Datentypen Implementiert werden k\u00f6nnen mit impl Trait for Type { ... } , und dass dieser Lexable Trait den Implementierer zwingt die lex_next Funktion und den Error Typen zu definieren. enum LexError { BadCharacter(char), ParseNumberError(ParseFloatError), UnclosedString, } impl Lexable for Token { type Error = LexError; fn lex_next<'a>(lexer: &mut Lexer<'a>) -> Result<Option<Located<Self>>, Located<Self::Error>> { ... } } Genau das mache ich hier f\u00fcr Token . Dort wo die drei Punkte sind werde ich in folge die [[#Schritte des Lexers]]. LexError ist ein enum um alle Fehler die entstehen k\u00f6nnen beim Lexen darzustellen.","title":"Lexer"},{"location":"Lexer/#schritte-des-lexers","text":"","title":"Schritte des Lexers"},{"location":"Lexer/#leerzeichen","text":"while let Some(c) = lexer.peek() { if !c.is_ascii_whitespace() { break; } lexer.next(); } let pos = lexer.pos(); let Some(c) = lexer.next() else { return Ok(None); }; ... Als erstes ist es wichtig alle Leerzeichen (dazu z\u00e4hlen auch Zeilenumbr\u00fcche) zu \u00fcberspringen, damit diese beliebig zwischen jedem Token stehen k\u00f6nnen. Daf\u00fcr ist die while let Schleife da. Danach merkt sicher der Lexer die Position un den ersten Buchstaben des zu lexendem Tokens.","title":"Leerzeichen"},{"location":"Lexer/#symbole","text":"match c { '=' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::EqualEqual, pos))) } else { Ok(Some(Located::new(Token::Equal, pos))) } } ',' => Ok(Some(Located::new(Token::Comma, pos))), '.' => Ok(Some(Located::new(Token::Dot, pos))), '(' => Ok(Some(Located::new(Token::ParanLeft, pos))), ')' => Ok(Some(Located::new(Token::ParanRight, pos))), '[' => Ok(Some(Located::new(Token::BracketLeft, pos))), ']' => Ok(Some(Located::new(Token::BracketRight, pos))), '{' => Ok(Some(Located::new(Token::BraceLeft, pos))), '}' => Ok(Some(Located::new(Token::BraceRight, pos))), '+' => Ok(Some(Located::new(Token::Plus, pos))), '-' => Ok(Some(Located::new(Token::Minus, pos))), '*' => Ok(Some(Located::new(Token::Star, pos))), '/' => Ok(Some(Located::new(Token::Slash, pos))), '%' => Ok(Some(Located::new(Token::Percent, pos))), '^' => Ok(Some(Located::new(Token::Exponent, pos))), '<' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::LessEqual, pos))) } else { Ok(Some(Located::new(Token::Less, pos))) } } '>' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::GreaterEqual, pos))) } else { Ok(Some(Located::new(Token::Greater, pos))) } } '&' => Ok(Some(Located::new(Token::Ampersand, pos))), '|' => Ok(Some(Located::new(Token::Pipe, pos))), '!' => { if lexer.peek() == Some(&'=') { lexer.next(); Ok(Some(Located::new(Token::ExclamationEqual, pos))) } else { Ok(Some(Located::new(Token::Exclamation, pos))) } } ... } Als erstes wird geschaut ob der Buchstabe ein bestimmtes Zeichen ist was f\u00fcr die Sprache von Bedeutung ist wie = oder + usw. Falls das der Fall ist geben wir einfach das Symbol als Token wider. Wie man sehen kann benutze ich daf\u00fcr den match Zweig, der in Rust ein sogenanntes Pattern-Matching (Mustervergleichen) benutzt um die Art des Buchstabens zu ermitteln. Es ist ein sehr n\u00fctzlicher Zweig, den ich immer wieder benutze, auch sp\u00e4ter.","title":"Symbole"},{"location":"Lexer/#strings","text":"match c { ... '\"' => { let mut string = String::new(); while let Some(c) = lexer.peek() { if *c == '\"' { break; } string.push(lexer.next().unwrap()) } if lexer.next() != Some('\"') { return Err(Located::new(LexError::UnclosedString, pos)) } Ok(Some(Located::new(Token::String(string), pos))) } ... } Ein spezielles Symbol f\u00fcr die Sprache ist das Anf\u00fchrungszeichen, denn zwei von diesen umgeben immer einen String. Das hei\u00dft wenn der Lexer eines begegnet, sammelt er alle Buchstaben bis er das n\u00e4chste Anf\u00fchrungszeichen hat, und dann gibt er diesen String als Token wider.","title":"Strings"},{"location":"Lexer/#zahlen","text":"match c { ... c if c.is_ascii_digit() => { let mut number = String::from(c); while let Some(c) = lexer.peek() { if !c.is_ascii_digit() { break; } number.push(lexer.next().unwrap()) } if lexer.peek() == Some(&'.') { number.push(lexer.next().unwrap()); while let Some(c) = lexer.peek() { if !c.is_ascii_digit() { break; } number.push(lexer.next().unwrap()) } } Ok(Some(Located::new( Token::Number( number .parse() .map_err(LexError::ParseNumberError) .map_err(|err| Located::new(err, pos.clone()))?, ), pos, ))) } ... } Zahlen werden auf diese Weise gefunden. Wenn der Buchstabe eine ASCII Nummer ist werden alle darauf folgenden ASCII Nummern erst in einem String gesammelt, der dann am Ende in eine Dezimalzahl umgewandelt wird. Falls der Lexer einem Punkt begegnet nimmt er diesen mit und sammelt noch alle Nummern die danach kommen auf.","title":"Zahlen"},{"location":"Lexer/#identifiers","text":"match c { ... c if c.is_alphanumeric() || c == '_' => { let mut ident = String::from(c); while let Some(c) = lexer.peek() { if !c.is_alphanumeric() && *c != '_' { break; } ident.push(lexer.next().unwrap()) } Ok(Some(Located::new(Token::ident(ident), pos))) } ... } Identifier werden auf die gleiche Art wie Zahlen aufgenommen, nur kann es hier keinen Punkt geben, was es noch einfacherer macht. Teile eines Identifiers sind alle Alpha-nummerische Buchstaben sowie Unterstriche. impl Token { ... fn ident(ident: String) -> Self { match ident.as_str() { \"let\" => Self::Let, \"def\" => Self::Def, \"if\" => Self::If, \"else\" => Self::Else, \"while\" => Self::While, \"for\" => Self::For, _ => Self::Ident(ident), } } ... } Falls der Identifier einen der Schl\u00fcsselw\u00f6rter entspricht, wird das Schl\u00fcsselwort wider gegeben und nicht der eigentliche Identifier.","title":"Identifiers"},{"location":"Lexer/#errors","text":"match c { ... c => Err(Located::new(LexError::BadCharacter(c), pos)), } Wenn keiner der vorherigen Muster gepasst hat, gibt der Lexer einen Fehler wider, der besagt, dass ein nicht erkennbarer Buchstabe in dem Input ist, und schlie\u00dft somit das Programm.","title":"Errors"},{"location":"Lexer/#sammeln","text":"fn lex(text: &str) -> Result<Vec<Located<Token>>, Located<LexError>> { let mut lexer = Lexer { chars: text.chars().peekable(), ln: 0, col: 0 }; let mut tokens = vec![]; while let Some(token) = Token::lex_next(&mut lexer)? { tokens.push(token) } Ok(tokens) } Diese Funktion f\u00fchrt die Beschrieben Schritte immer wieder aus bis es am Ende des Inputs angekommen ist. Somit erhalten wir am Ende eine Liste mit Tokens und k\u00f6nnen nun weiter mit dem Parsing machen. Weiter zum Parser .","title":"Sammeln"},{"location":"Parser/","text":"Ziel Das Ziel eines Parser ist es die vom lexer erstellten Token in eine Abstract-Syntax-Tree (abstrakter Syntaxbaum) umzuwandeln. Der Input: 1 + 2 * 3 Die Tokens: [NUMBER(1)] [PLUS] [NUMBER(2)] [STAR] [NUMBER(3)] Der AST: + / \\ 1 * / \\ 2 3 In JSON dargestellt: { \"operator\": \"+\", \"left\": 1, \"right\": { \"operator\": \"*\", \"left\": 2, \"right\": 3 } } Parser Expression Grammar Nat\u00fcrlich soll unser parser noch mehr Arten von ASTs erkennen k\u00f6nnen als nur Bin\u00e4re Operationen. Zum Beispiel eine Variabel-Erstellung. Um Parser aufschreiben zu k\u00f6nnen benutzt man meistens PEG (Parsing Expression Grammar). F\u00fcr die Bin\u00e4r Operationen s\u00e4he der PEG Code so aus: expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: IDENT | NUMBER | '(' expr ')' Es gibt sozusagen Layer die einen Name haben und in diesen beschreibt man die Muster die in dem Layer auftreten d\u00fcrfen. PEG Code f\u00fcr meine Sprache Hier ist die ganze Grammatik f\u00fcr meine Sprache: chunk: [(statement)*] statement: 'let' ident '=' expr | 'def' ident '(' [ident (',' ident)*] ')' block | if-statement | 'while' expr block | 'return' expr | ident '(' [expr (',' expr)*] ')' | ident '=' expr | block if-statement: 'if' expr block | 'if' expr block 'else' block | 'if' expr block 'else' if-statement block: '{' [(statement)*] '}' expr: | expr '(' [expr (',' expr)*] ')' | comp comp: comp '==' arith | comp '!=' arith | comp '<' arith | comp '>' arith | comp '<=' arith | comp '>=' arith | arith arith: arith '+' term | arith '-' term | arith term: term '*' exp | term '/' exp | term '%' exp | exp exp: exp '^' not | not not: '!' not | neg neg: '-' neg | atom atom: IDENT | NUMBER | STRING | '(' expr ')' In Rust Der Rust Code ist fast so wie der PEG Code, nur dass ich die Bin\u00e4ren Operationen vereinfacht habe, was den ganzen Code kleiner macht und mir erlaubt sp\u00e4ter vielleicht mehr Operatoren einfacher hinzuzuf\u00fcgen. struct Chunk(Vec<Located<Statement>>); struct Block(Vec<Located<Statement>>); enum Statement { Block(Block), Let { ident: Located<String>, expr: Located<Expression>, }, Assign { ident: Located<String>, expr: Located<Expression>, }, Call { ident: Located<String>, args: Vec<Located<Expression>>, }, Def { ident: Located<String>, params: Vec<Located<String>>, body: Located<Block>, }, If { cond: Located<Expression>, case: Located<Block>, else_case: Option<Located<Block>>, }, While { cond: Located<Expression>, body: Located<Block>, }, Return(Located<Expression>), } enum Expression { Atom(Atom), Binary { op: BinaryOperator, left: Box<Located<Self>>, right: Box<Located<Self>>, }, Unary { op: UnaryOperator, right: Box<Located<Self>>, }, Call { head: Box<Located<Self>>, args: Vec<Located<Self>>, }, } enum BinaryOperator { Plus, // + Minus, // - Star, // * Slash, // / Percent, // % Exponent, // ^ EqualEqual, // == ExclamationEqual, // != Less, // < Greater, // > LessEqual, // <= GreaterEqual, // >= Ampersand, // & Pipe, // | } enum UnaryOperator { Minus, // - Exclamation, // ! } enum Atom { Ident(String), Number(f64), String(String), Expression(Box<Located<Expression>>), } Daf\u00fcr habe ich auch folgenden Code angelegt um die Operatoren Reihenfolge einfach darzustellen k\u00f6nnen und ver\u00e4ndern zu k\u00f6nnen. impl BinaryOperator { const LAYER: &'static [&'static [Self]] = &[ &[Self::Ampersand, Self::Pipe], &[ Self::EqualEqual, Self::ExclamationEqual, Self::Less, Self::Greater, Self::LessEqual, Self::GreaterEqual, ], &[Self::Plus, Self::Minus], &[Self::Star, Self::Slash, Self::Percent], &[Self::Exponent], ]; fn layer(layer: usize) -> Option<&'static [Self]> { Self::LAYER.get(layer).copied() } fn token(token: &Token) -> Option<Self> { match token { Token::Plus => Some(Self::Plus), Token::Minus => Some(Self::Minus), Token::Star => Some(Self::Star), Token::Slash => Some(Self::Slash), Token::Percent => Some(Self::Percent), Token::Exponent => Some(Self::Exponent), Token::EqualEqual => Some(Self::EqualEqual), Token::ExclamationEqual => Some(Self::ExclamationEqual), Token::Less => Some(Self::Less), Token::Greater => Some(Self::Greater), Token::LessEqual => Some(Self::LessEqual), Token::GreaterEqual => Some(Self::GreaterEqual), Token::Ampersand => Some(Self::Ampersand), Token::Pipe => Some(Self::Pipe), _ => None, } } } impl UnaryOperator { pub const LAYER: &'static [&'static [Self]] = &[ &[Self::Exclamation], &[Self::Minus] ]; pub fn layer(layer: usize) -> Option<&'static [Self]> { Self::LAYER.get(layer).copied() } pub fn token(token: &Token) -> Option<Self> { match token { Token::Minus => Some(Self::Minus), Token::Exclamation => Some(Self::Exclamation), _ => None, } } } Die Konstante LAYER in beiden Implementierungen hat ein statische Referenz zu einem Array wo Arrays mit Operatoren drin sind (auch statische Referenz). Dieser ist daf\u00fcr da sp\u00e4ter beim parsen die Layer nach Index identifizieren zu k\u00f6nnen. Wenn der Parser bei Layer n ist, wei\u00df er, dass er als n\u00e4chstes zu Layer n + 1 muss. Diese Optimierung habe nach \u00f6fteren Parser kreieren selber entwickelt, dennoch kann ich mir vorstellen, dass das schon jemanden vor mir erfunden hat, aber so lange ich das nicht wei\u00df, werde ich mir immer wieder selber auf die Schulter klopfen :) Beispiele Hier ein paar Beispiele wie ein Source Code in dieser Sprache aussehen k\u00f6nnte let a = 1 print(a) while yes() { print(\"still not done...\") } let a = 3 if a == 1 { print(\"one\") } else if a == 2 { print(\"tow\") } else { print(\"no idea :(\") } Errors F\u00fcr die Fehler die beim Parsen enstehen k\u00f6nnen habe ich folgenden Error enum geschrieben: enum ParseError { UnexpectedEOF, // unexpected end of file UnexpectedToken(Token), // unexpected token $0 ExpectedToken { // expected $expected, got $got expected: Token, got: Token }, } Das sind alle Fehler-Varianten, die bei diesem Parser auftreten k\u00f6nnen, doch andere Parser k\u00f6nnen nat\u00fcrlich mehr besitzen, was meistens der Fall f\u00fcr kompliziertere Sprachen ist, aber da ich nur eine Beispielsprache mache, ist das genug. Weiter zum Compiler","title":"Parser"},{"location":"Parser/#ziel","text":"Das Ziel eines Parser ist es die vom lexer erstellten Token in eine Abstract-Syntax-Tree (abstrakter Syntaxbaum) umzuwandeln. Der Input: 1 + 2 * 3 Die Tokens: [NUMBER(1)] [PLUS] [NUMBER(2)] [STAR] [NUMBER(3)] Der AST: + / \\ 1 * / \\ 2 3 In JSON dargestellt: { \"operator\": \"+\", \"left\": 1, \"right\": { \"operator\": \"*\", \"left\": 2, \"right\": 3 } }","title":"Ziel"},{"location":"Parser/#parser-expression-grammar","text":"Nat\u00fcrlich soll unser parser noch mehr Arten von ASTs erkennen k\u00f6nnen als nur Bin\u00e4re Operationen. Zum Beispiel eine Variabel-Erstellung. Um Parser aufschreiben zu k\u00f6nnen benutzt man meistens PEG (Parsing Expression Grammar). F\u00fcr die Bin\u00e4r Operationen s\u00e4he der PEG Code so aus: expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: IDENT | NUMBER | '(' expr ')' Es gibt sozusagen Layer die einen Name haben und in diesen beschreibt man die Muster die in dem Layer auftreten d\u00fcrfen.","title":"Parser Expression Grammar"},{"location":"Parser/#peg-code-fur-meine-sprache","text":"Hier ist die ganze Grammatik f\u00fcr meine Sprache: chunk: [(statement)*] statement: 'let' ident '=' expr | 'def' ident '(' [ident (',' ident)*] ')' block | if-statement | 'while' expr block | 'return' expr | ident '(' [expr (',' expr)*] ')' | ident '=' expr | block if-statement: 'if' expr block | 'if' expr block 'else' block | 'if' expr block 'else' if-statement block: '{' [(statement)*] '}' expr: | expr '(' [expr (',' expr)*] ')' | comp comp: comp '==' arith | comp '!=' arith | comp '<' arith | comp '>' arith | comp '<=' arith | comp '>=' arith | arith arith: arith '+' term | arith '-' term | arith term: term '*' exp | term '/' exp | term '%' exp | exp exp: exp '^' not | not not: '!' not | neg neg: '-' neg | atom atom: IDENT | NUMBER | STRING | '(' expr ')'","title":"PEG Code f\u00fcr meine Sprache"},{"location":"Parser/#in-rust","text":"Der Rust Code ist fast so wie der PEG Code, nur dass ich die Bin\u00e4ren Operationen vereinfacht habe, was den ganzen Code kleiner macht und mir erlaubt sp\u00e4ter vielleicht mehr Operatoren einfacher hinzuzuf\u00fcgen. struct Chunk(Vec<Located<Statement>>); struct Block(Vec<Located<Statement>>); enum Statement { Block(Block), Let { ident: Located<String>, expr: Located<Expression>, }, Assign { ident: Located<String>, expr: Located<Expression>, }, Call { ident: Located<String>, args: Vec<Located<Expression>>, }, Def { ident: Located<String>, params: Vec<Located<String>>, body: Located<Block>, }, If { cond: Located<Expression>, case: Located<Block>, else_case: Option<Located<Block>>, }, While { cond: Located<Expression>, body: Located<Block>, }, Return(Located<Expression>), } enum Expression { Atom(Atom), Binary { op: BinaryOperator, left: Box<Located<Self>>, right: Box<Located<Self>>, }, Unary { op: UnaryOperator, right: Box<Located<Self>>, }, Call { head: Box<Located<Self>>, args: Vec<Located<Self>>, }, } enum BinaryOperator { Plus, // + Minus, // - Star, // * Slash, // / Percent, // % Exponent, // ^ EqualEqual, // == ExclamationEqual, // != Less, // < Greater, // > LessEqual, // <= GreaterEqual, // >= Ampersand, // & Pipe, // | } enum UnaryOperator { Minus, // - Exclamation, // ! } enum Atom { Ident(String), Number(f64), String(String), Expression(Box<Located<Expression>>), } Daf\u00fcr habe ich auch folgenden Code angelegt um die Operatoren Reihenfolge einfach darzustellen k\u00f6nnen und ver\u00e4ndern zu k\u00f6nnen. impl BinaryOperator { const LAYER: &'static [&'static [Self]] = &[ &[Self::Ampersand, Self::Pipe], &[ Self::EqualEqual, Self::ExclamationEqual, Self::Less, Self::Greater, Self::LessEqual, Self::GreaterEqual, ], &[Self::Plus, Self::Minus], &[Self::Star, Self::Slash, Self::Percent], &[Self::Exponent], ]; fn layer(layer: usize) -> Option<&'static [Self]> { Self::LAYER.get(layer).copied() } fn token(token: &Token) -> Option<Self> { match token { Token::Plus => Some(Self::Plus), Token::Minus => Some(Self::Minus), Token::Star => Some(Self::Star), Token::Slash => Some(Self::Slash), Token::Percent => Some(Self::Percent), Token::Exponent => Some(Self::Exponent), Token::EqualEqual => Some(Self::EqualEqual), Token::ExclamationEqual => Some(Self::ExclamationEqual), Token::Less => Some(Self::Less), Token::Greater => Some(Self::Greater), Token::LessEqual => Some(Self::LessEqual), Token::GreaterEqual => Some(Self::GreaterEqual), Token::Ampersand => Some(Self::Ampersand), Token::Pipe => Some(Self::Pipe), _ => None, } } } impl UnaryOperator { pub const LAYER: &'static [&'static [Self]] = &[ &[Self::Exclamation], &[Self::Minus] ]; pub fn layer(layer: usize) -> Option<&'static [Self]> { Self::LAYER.get(layer).copied() } pub fn token(token: &Token) -> Option<Self> { match token { Token::Minus => Some(Self::Minus), Token::Exclamation => Some(Self::Exclamation), _ => None, } } } Die Konstante LAYER in beiden Implementierungen hat ein statische Referenz zu einem Array wo Arrays mit Operatoren drin sind (auch statische Referenz). Dieser ist daf\u00fcr da sp\u00e4ter beim parsen die Layer nach Index identifizieren zu k\u00f6nnen. Wenn der Parser bei Layer n ist, wei\u00df er, dass er als n\u00e4chstes zu Layer n + 1 muss. Diese Optimierung habe nach \u00f6fteren Parser kreieren selber entwickelt, dennoch kann ich mir vorstellen, dass das schon jemanden vor mir erfunden hat, aber so lange ich das nicht wei\u00df, werde ich mir immer wieder selber auf die Schulter klopfen :)","title":"In Rust"},{"location":"Parser/#beispiele","text":"Hier ein paar Beispiele wie ein Source Code in dieser Sprache aussehen k\u00f6nnte let a = 1 print(a) while yes() { print(\"still not done...\") } let a = 3 if a == 1 { print(\"one\") } else if a == 2 { print(\"tow\") } else { print(\"no idea :(\") }","title":"Beispiele"},{"location":"Parser/#errors","text":"F\u00fcr die Fehler die beim Parsen enstehen k\u00f6nnen habe ich folgenden Error enum geschrieben: enum ParseError { UnexpectedEOF, // unexpected end of file UnexpectedToken(Token), // unexpected token $0 ExpectedToken { // expected $expected, got $got expected: Token, got: Token }, } Das sind alle Fehler-Varianten, die bei diesem Parser auftreten k\u00f6nnen, doch andere Parser k\u00f6nnen nat\u00fcrlich mehr besitzen, was meistens der Fall f\u00fcr kompliziertere Sprachen ist, aber da ich nur eine Beispielsprache mache, ist das genug. Weiter zum Compiler","title":"Errors"},{"location":"Was%20ist%20ein%20Compiler/","text":"Ein Compiler einer Programmiersprachen hat an sich nur eine Funktion: Text in Computer-Anweisungen umzuwandeln. Hierbei gibt es jedoch einen starken unterschied zwischen compilierten und interpretierten Programmiersprachen. Der Hauptunterschied ist, dass Source Code compilierter Sprachen in f\u00fcr die CPU verst\u00e4ndliche Anweisungen umgewandelt wird und meist in einer neuen Datei gespeichert wird, dennoch bei interpretierten Sprachen der Source Code lediglich von einem Interpreten ausgef\u00fchrt und nie in tats\u00e4chliche CPU Anweisungen umgeschrieben wird. Der Interpreter hat dabei meist seine eigenen Anweisungen (Byte Codes) die spezifisch f\u00fcr die Sprache oder Sprachgruppen gedacht sind. Wichtig ist zu verstehen, dass der Interpreter Byte Code einen Interpreter braucht , da er nicht einfach auf der CPU eines Systems laufen kann. Das hei\u00dft diese Interpreter m\u00fcssen erst einmal in einer anderen Sprache geschrieben werden (in meinem Fall habe ich Rust gew\u00e4hlt, aber man kann diese in jeder beliebigen Sprache schreiben) . Beide Arten von Programmiersprachen haben ihre nach und Vorteile: Programmiersprachen Art Pros Cons Interpretiert Sofortige Ausf\u00fchrung des Programms (Kein Compilationsschritt) Kein tiefes Verst\u00e4ndnis f\u00fcr Computer n\u00f6tig Dynamische Variablen Externer Interpret muss runtergeladen werden Die Performance ist schlechter (abh\u00e4ngig von der Implementierung) Compiliert Kann direkt auf dem und gleichen CPUs ausgef\u00fchrt werden ohne das Compiler Programm Der Code ist so schnell wie die CPU Mehr Kontrolle \u00fcber die Speichernutzung Programme m\u00fcssen auf verschiedenen CPUs verschieden compiliert werden (wichtig f\u00fcr Multi-Plattform Applikationen) Nach \u00e4ndern des Source Codes muss dieser jedes mal neu compiliert werden Beide Arten der Programmiersprachen Implementierung haben ihre Vor- und Nachteile und m\u00fcssen deswegen f\u00fcr das Ziel der Programmiersprache ausgew\u00e4hlt werden. F\u00fcr meine Implementierung einer einfachen Programmiersprache habe ich mich f\u00fcr einen Interpreter entschieden, weil Compiler ohne ein gutes Verst\u00e4ndnis von Computern schwer ist zu verstehen. Weiter zu Aufbau eines Compilers","title":"Was ist ein Compiler"}]}